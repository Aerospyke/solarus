Prochaines mises à jour :

- fausse boîte
- mode d'emploi


Démo :

- Version alpha 1 (r1093) : envoyée aux testeurs, touches de test activées (DEBUG_LEVEL = 2)
- Version beta 1 (r1103) : même chose, la version alpha étant assez stable
- Version RC1 (r1128) : DEBUG_LEVEL = 0
- Version RC2 : r1155
- Version RC3 : r1174
- Version finale 1.0 : r1176


Version gentoo svn :
games-rpg/solarus from  gamerlay overlay


Feature requests :

- Mettre de la couleur dans les messages
- Ajouter des infos de statut quête dans l'écran de sélection des sauvegardes, en particulier quand une sauvegarde est choisie
- Rendre les pancartes soulevables
- Permettre aux ennemis de tomber dans les trous
- Permettre aux objets portés de tomber dans les trous et dans l'eau
- Mettre des constantes dans les scripts
- transition intérieur / extérieur : ovale
- transition des téléporteurs ?
- rendre les pierres et les buissons dépendants du tileset
- scrolling tiles : permettre de choisir la direction du décalage
- Ce serait pas mal de faire une animation lorsque Link vide le contenu de sa bouteille.
- Ajouter un "map marker" pour indiquer où il faut se rendre ensuite
- Voir si la police supporte des caractères unicode comme U+2192 (→) et U+2190 (←)
- faire un type d'ennemi "CustomEnemy" qui est en fait scripté
- renommer Tileset en Skin ?
- Faire une function lua event_npc_interaction_item


Bugs :

- plein écran se déclenche parfois avec des combinaisons de espace, gauche, haut (il croit que F5 a été appuyé)
- quand ça rame (exemple Wink ou valgrind), les vases et le boomerang sont lancés moins loin
- quand ça rame (exemple Wink), possible de sortir de la pâtisserie pendant le dialogue "hé, attends" : corrigé depuis le freeze() de event_hero_on_sensor ?
- la palette de couleurs des sprites de newlink n'est pas la même que celle du jeu original, il faudrait corriger quelques couleurs.
- trous et plates-formes dans la grotte de mymy
- path finding : ne pas explorer les noeuds trop loin de la cible (on perd du temps à s'éloigner sans grand espoir)
- PathFinding : si pas de chemin mais pas trop loin, essayer de s'approcher quand même
- mur fissuré qui explose : animation ?
- curseur visible sur eeepc linux en plein écran
- le 8 n'est pas très lisible (ex : 80 rubis chez le forgeron)
- engine_dialogs.zsd : deux fois _treasure_88_2 (le signaler aux traducteurs)
- empêcher de lancer le jeu en root, sinon le config.ini est créé avec root comme propriétaire
- mode d'emploi : enlever le logo nintendo sur la dernière page
- mode d'emploi : page 13 : "vous pouvez la possibilité"
- pousser un buisson empêche de le soulever
- Link semble disparaître un peu lors des phases à l'épée.
- Lorsqu'on fait des appuis courts et répétés sur une des flèches, Link avance sans marcher.
- Quand Link rentre dans une maison, le cadre de la porte est sous sa tête et pas au-dessus.
- Au moment où on frappe les gardes verts qui rôdent près du village, il se peut que ceux-ci ne reculent pas malgré l'impact s'ils changent de direction au même moment.
- On ne peut pas lancer un pot au-dessus d'une falaise
- Quand on lance un pot dans un donjon depuis la couche intermédiaire vers la couche basse, le changer de couche (détecter l'absence de tiles sur la couche intermédiaire)
- vérifier ce qui se passe si on arrive sur un tapis roulant pendant qu'on tire une statue (peut-être modifier le is_conveyor_belt_obstacle)
- Morwenn : Quand on reste l'épée brandie vers le bas, et qu'on tue un monstre, on peut continuer à avancer. -> Empêcher surtout le monstre d'attaquer le héros pendant un certain délai, cela éviterait aussi que les ennemis interrompent les bottes de pégase.
  Cependant, on se blesse même si on le touche alors qu'il en est à son animation de destruction.
- achat d'un croissant : dialogue avant et après l'achat redondant


A venir :

- Prochains types d'entités :
  - blocs violets


Ennemis à faire (reprendre graphismes de MC + graphismes rippés) :

- GreenSoldier : garde vert normal (intelligent avec longue épée)
- Octorok
- serpent
- stalfos
- méduse
- crabe
- Armos
- fantôme
- garde bleu avec lance (monde des ténèbres)


----------------------------------
Scripts des objets de l'inventaire
----------------------------------

Plusieurs fonctions d'objets d'inventaire :
- bombs
- bow
- boomerang
- lamp
- hookshot
- bottle
- speed_shoes
- flippers
- glove
- block_maker
- weak_wall_detector
- custom_unassignable
- custom_interaction
- custom_script

Faire un fichier de données de type ini (dans info.dat ?) qui donne la liste
des items de chaque slot (sans les variantes)
en indiquant son compteur éventuel avec la valeur maximale

  INVENTORY_FEATHER                     = 0,
  INVENTORY_BOMBS                       = 1,
  INVENTORY_BOW                         = 2, /**< 1: bow without arrows, 2: bow with arrows */
  INVENTORY_BOOMERANG                   = 3,
  INVENTORY_LAMP                        = 4,
  INVENTORY_HOOK_SHOT                   = 5,
  INVENTORY_BOTTLE_1                    = 6, /**< 1: empty, 2: water, 3: red potion, 4: green potion, 5: blue potion, 6: fairy */

  INVENTORY_SPEED_SHOES                 = 7,
  INVENTORY_MYSTIC_MIRROR               = 8,
  INVENTORY_CANE_OF_SOMARIA             = 9,
  INVENTORY_APPLES                      = 10,
  INVENTORY_PAINS_AU_CHOCOLAT           = 11,
  INVENTORY_CROISSANTS                  = 12,
  INVENTORY_BOTTLE_2                    = 13,

  INVENTORY_ROCK_KEY                    = 14,
  INVENTORY_RED_KEY                     = 15,
  INVENTORY_CLAY_KEY                    = 16,
  INVENTORY_L4_WAY_BONE_KEY             = 17, /**< 1: apple pie, 2: gold bars, 3: edelweiss, 4: bone key */
  INVENTORY_FLIPPERS                    = 18,
  INVENTORY_MAGIC_CAPE                  = 19,
  INVENTORY_BOTTLE_3                    = 20,

  INVENTORY_IRON_KEY                    = 21,
  INVENTORY_STONE_KEY                   = 22,
  INVENTORY_WOODEN_KEY                  = 23,
  INVENTORY_ICE_KEY                     = 24,
  INVENTORY_GLOVE                       = 25, /**< 1: iron glove, 2: golden glove */
  INVENTORY_FIRE_STONES                 = 26,
  INVENTORY_BOTTLE_4                    = 27



-----------------
Scripts d'ennemis
-----------------

Chaque type d'ennemi scripté est défini dans un fichier de script Lua.
Exemple : garde vert avec grande épée
L'ennemi est placé sur l'éditeur de maps avec comme sous-type "Custom Enemy"
et une information supplémentaire "green_soldier"
Cette information supplémentaire est à choisir dans une liste déroulante
remplie par un examen du répertoire des scripts d'ennmis (pas cohérent avec les autres
ressources) ou comme une ressource de la base de données (au même titre qu'une map, une musique, etc.)

Le fichier enemies/green_soldier.lua contient la description et le comportement de l'ennemi.
La classe EnemyScript fait le lien entre les fonctions des scripts d'ennemis et le moteur de jeu
(en particulier la classe Enemy).

Il peut y avoir plusieurs gardes verts sur la même map.

Choix possibles :

non 1) Une instance de EnemyScript gère 1 garde. Lourd car beaucoup de scripts à instancier, analyser et beaucoup de contextes lua en mémoire
oui 2) Une instance de EnemyScript gère tous les gardes d'un type. Le contexte Lua contient le nom du type (ici "green_soldier").


Il faut pouvoir indiquer au moteur les caractéristiques de l'ennemi (utiliser un grand tableau indexé par des string) :

- initial_life
- damage_on_hero
- hurt_sound_style
- pushed_back_when_hurt
- push_back_hero_on_sword
- minimum_shield_needed
- attack_consequences

indiquer cela au moteur une seule fois de façon globale car ça ne change pas en fonction des ennemis


Lua -> C++ :

enemy_create_sprite(…)
enemy_set_movement(…)


C++ -> Lua :

event_initialization()				appelé à l'initialisation du script 
event_enemy_created(enemy_name)			appelé à la création d'un de ce type

______________
Fichier type :


features = {
  initial_life = 10,
  damage_on_hero = 1,
  attack_consequences = {
    attack_sword = -1,
    attack_explosion = 1
  }
}

set_features(features)

function event_enemy_created(enemy_name)
  create_sprite("green_soldier_body")
  create_sprite("green_soldier_sword")
  set_movement(movements.RANDOM_WALK)
end

function event_enemy_hurt(source, attack, life_points)
  
end
_____________________

-- faire un script prédéfini qui fournit ce code ainsi que des constantes comme attack_sword, attack_explosion, etc
-- pareil pour les scripts des maps qui n'ont pas de constantes
function set_features(features)
  enemy_type_set_initial_life(features.initial_life)
  enemy_type_set_damage_on_hero(features.damage_on_hero)
  enemy_type_set_attack_consequence(attacks.SWORD, features.attack_consequences.attack_sword)
  enemy_type_set_attack_consequence(attacks.EXPLOSION, features.attack_consequences.attack_explosion)
end

-- possibilité que ce script prédéfini fournisse le moyen aux scripts normaux de s'abstraire du nom de l'ennemi ?
-- avec une variable globale qui retient le nom de l'ennemi courant

--------------
Mode release :
--------------

- Ne plus afficher les messages d'erreur (en modifiant le define RELEASE_MODE)
- Forcer l'ouverture des fichiers de données depuis le fichier zip et interdire depuis l'arborescence (en modifiant le define RELEASE_MODE)
- Enelever les touches de test (en modifiant le define RELEASE_MODE)
- Compiler en mode release (pas -g) et optimisé
- Inclure le fichier de licence GPL
- Vérifier la présence du message GPL dans les fichiers source
- Compiler les scripts et enlever les versions en texte clair
- Vérifier les TODO du code et de data
- Windows : installeur avec InnoSetup
- Enlever project_db.zsd


----------------------
Feature requests de l'éditeur :

- Compléter l'éditeur de maps et de tilesets :
	- Dans l'éditeur de tileset, étudier le problème de permettre de modifier un tile sans avoir à le supprimer (pour conserver le même indice)
	- vue arborescente de toutes les entités par type ?
	- choisir les types d'entités affichés
	- nouveau projet : créer le fichier resource_db.zsd automatiquement, le répertoire data et les sous-répertoires
	- empêcher de mettre des entités au-delà de la partie extérieure d'une map
	- ResourceDatabase: créer les objets de chaque ressource depuis là, pour les fournir aux autres, ça évitera que chacun les recrée quand il a besoin (réfléchir au fait que les maps par exemple ne seront pas rechargées)
	- Editeur de tileset : ajouter le choix des animations dans le popup menu
	- Quand on annule une suppression ou qu'on fait un copier-coller, les plans ne sont pas respectés
	- Editeur de maps : sélectionner uniquement les objets visibles (non obstacles / obstacles cochés ou pas)
	- Dézoomer avec Ctrl + molette
	- Parser les fichiers de sprite dans l'éditeur (utile pour PNJ et entités avec skin)
	- Eviter d'avoir à recharger la map pour voir les destinations mises à jour
	- Affichage : dessiner les tiles une seule fois sur une surface intermédiaire au lieu de les redessiner un par un à chaque affichage (c'est possible dans l'éditeur mais pas facilement dans le jeu à cause des tiles animés)
	- Permettre de modifier les textes "Direction", "Subtype", etc... depuis les sous-classes de EditEntityComponent afin de rendre certains plus explicites (exemple : mettre "Pushing direction" pour les blocs)
	- Interface pour éditer les étages des donjons
	- dungeons.dat : l'emplacement des coffres et des boss est censé être relatif à l'étage, pas à la map
