/**
@page lua_api_specification Lua scripting API specification

We give here the list of Lua functions that are called by the C++ engine
(such functions are called events),
and the list of C++ functions that may be called by Lua scripts.
This documentation page is intented to Lua programers who want to know the
functions available.
For the point of view of the engine, see the documentation of the C++ class
Script and its subclasses.

For now, the following types of scripts exist:
- The script of a map (<tt>maps/mapXXXX.lua</tt>): controls the map XXXX.
- The script of an enemy (<tt>enemies/XXXX.lua</tt>): controls an enemy whose
breed is "XXXX". Each instance of enemy has its own Lua state (in particular
its own global values), even if several enemies of the same breed exist at the
same time on the current map.
- The script of an item (<tt>items/XXXX.lua</tt>): controls the item named
"XXXX" in <tt>items.dat</tt>. For each item, only one Lua state is created for
the whole game and it persists across map changes.
- The script of a menu (<tt>menus/XXXX.lua</tt>): controls a menu displayed
before or during the game.

Other types or scripts might be available in the future.

A Lua script can call C++ functions through a global table called <tt>sol</tt>.
The functions are organized into several APIs.
The APIs that are available to your script depend on the type of script.
For now, the following APIs are implemented:
- <tt>sol.main</tt>: basic functions available to all types of scripts, even
outside a game.
- <tt>sol.game</tt>: this module represents the current game. It provides
functions to manage game information such as the savegame and the equipment.
- <tt>sol.map</tt>: this module represents the current map.
It provides functions to manage the entities placed on the map,
including the hero.
- <tt>sol.item</tt>: this module represents a particular type of equipment item, and
possibly, depending on the current context, an instance of pickable item present on the map
or an instance of inventory item currently being used by the hero.
- <tt>sol.enemy</tt>: this module represents the current instance of an enemy.
- <tt>sol.movement</tt>: create and manage movements.
- <tt>sol.sprite</tt>: display animated images.
- <tt>sol.surface</tt>: display fixed images.
- <tt>sol.text_surface</tt>: display text.
- <tt>sol.input</tt>: handle low-level input events (keyboard, joypad)

The C++ code can also call Lua functions to notify the scripts that an event happened.

@section lua_to_cpp Calling C++ from Lua

We describe here all functions provided to Lua scripts
through the <tt>sol</tt> object.

@subsection sol.main Module <tt>sol.main</tt>

The <tt>sol.main</tt> module is available to any type of Lua script,
even when no game is running.
It contains functions to play sounds or musics and set timers.

- <tt>sol.main.include(script_name)</tt>:	
Includes another script into this one.

- <tt>sol.main.exit()</tt>:
Exits the program.

- <tt>sol.main.start_screen(screen_name)</tt>:
Ends the scripted screen or game that was running and starts a scripted screen.
  - <tt>screen_name</tt> (string): name of the scripted to load, relative to
    the <tt>screens</tt>directory (without the <tt>.lua</tt> extension)

- <tt>sol.main.play_sound(sound_id)</tt>:
Plays a sound.
  - <tt>sound_id</tt>: name of the sound file to play, relative to the
    <tt>sounds</tt> directory, without extension

- <tt>sol.main.play_music(music_id)</tt>:
Plays a music.
  - <tt>music_id</tt>: name of the music file to play, relative to the
    <tt>musics</tt> directory, or <tt>"none"</tt> or <tt>"same"</tt>

- <tt>sol.main.stop_music()</tt>:
Stops playing music.
Equivalent to <tt>sol.main.play_music("none")</tt>.

- <tt>sol.main.timer_start(function, duration, with_sound)</tt>:
starts a timer which will calls a function once finished
(with_sound is optional, default is false)

- <tt>sol.main.timer_stop_all()</tt>:
stops all timers started by your script

- <tt>sol.main.get_distance(x1, y1, x2, y2)</tt>:
Returns the distance in pixels between two points.

- <tt>sol.main.get_angle(x1, y1, x2, y2)</tt>:
Returns the angle in radians between the specified vector and the x axis.

@subsection sol.game Module <tt>sol.game</tt>

This module provides a datatype "game" that represents a savegame.
This type provides methods to manage the game data.

- <tt>sol.game.exists(file_name)</tt>:
Returns whether the specified savegame file exists.
  - <tt>file_name</tt> (string): name of the file to test, relative to the
    savegames directory.
  - Return value (boolean): true if this savegame file exists

- <tt>sol.game.load(file_name)</tt>:
Loads an existing savegame, or creates a new one if the file does not exist.
This function does not start the game, it just loads the savegame file.
Then you can access the data saved in the file.
To actually run the game, call the <tt>start()</tt> method.
  - <tt>file_name</tt> (string): name of the file to load or create, relative
    to the savegames directory
  - Return value (game): the loaded (or created) game

- <tt>game:save()</tt>:
Saves this game into its savegame file.

- <tt>game:start()</tt>:
Ends the scripted screen or game that was running and starts this game.
You can call this function to restart the current game itself,
even if it was not saved recently (no data will be lost).

- <tt>game:get_string(index)</tt>:
Returns a string saved.
  - <tt>index</tt> (number): index of the string variable to get from the
    savegame (0 to 63)
  - Return value (string): the corresponding string

- <tt>game:set_string(index, value)</tt>:
Sets a string in the savegame.
  - <tt>index</tt> (number): index of the string variable to set (32 to 63)
  - <tt>value</tt> (string): the string value to set

- <tt>game:get_integer(index)</tt>:
Returns an integer saved.
  - <tt>index</tt> (number): index of the integer variable to get from the
    savegame (0 to 2047)
  - Return value (number): the corresponding integer

- <tt>game:set_integer(index, value)</tt>:
Sets an integer in the savegame.
  - <tt>index</tt> (number): index of the integer variable to set (1024 to 2047)
  - <tt>value</tt> (number): the integer value to set

- <tt>game:get_boolean(index)</tt>:
Returns a boolean saved.
  - <tt>index</tt> (number): index of the boolean variable to get from the
    savegame (0 to 32767)
  - Return value (boolean): the corresponding boolean

- <tt>game:set_boolean(index, value)</tt>:
Sets an boolean in the savegame.
  - <tt>index</tt> (number): index of the boolean variable to set (0 to 32767)
  - <tt>value</tt> (boolean): the boolean value to set

- <tt>game:get_player_name()</tt>:
Returns the name of the player.
  - Return value (string): name of the player

- <tt>game:set_player_name(name)</tt>:
Sets the name of the player.
  - <tt>name</tt> (string): name of the player.

- <tt>game:get_life()</tt>:
Returns the current level of life of the player.
  - Return value (number): the current life

- <tt>game:set_life(life)</tt>:
Sets the level of life of the player.
A negative value will be replaced by zero. A value greater than
than the maximum level of life will be replaced by the maximum value.
  - <tt>life</tt> (number): number of life points to set

- <tt>game:add_life(life)</tt>:
Adds some life to the player.
  - <tt>life</tt> (number): number of life points to add

- <tt>game:remove_life(life)</tt>:
Removes some life from the player.
  - <tt>life</tt> (number): number of life points to remove

- <tt>game:get_max_life()</tt>:
Returns the maximum level of life of the player.
  - Return value (number): the maximum number of life points

- <tt>game:set_max_life(life)</tt>:
Sets the maximum level of life of the player.
  - <tt>life</tt> (number): maximum number of life points to set

- <tt>game:add_max_life(life)</tt>:
Increases the maximum level of life of the player.
  - <tt>life</tt> (number): maximum number of life points to set

- <tt>game:get_money()</tt>:
Returns the amount of money of the player.
  - Return value (number): the current amount of money

- <tt>game:set_money(money)</tt>:
Sets the amount of money of the player.
  - <tt>money</tt> (number): the amount of money to set

- <tt>game:add_money(money)</tt>:
Adds some money to the player.
  - <tt>money</tt> (number): amount of money to add

- <tt>game:remove_money(money)</tt>:
Removes some money from the player.
  - <tt>money</tt> (number): amount of money to remove

- <tt>game:get_magic()</tt>:
Returns the current number of magic points.
  - Return value (number): the current number of magic points

- <tt>game:set_magic(magic)</tt>:
Sets the amount of magic points of the player.
  - <tt>magic</tt> (number): the number of magic points to set

- <tt>game:add_magic(magic)</tt>:
Adds some magic points to the player.
  - <tt>magic</tt> (number): number of magic points to add

- <tt>game:remove_magic(magic)</tt>:
Removes some magic points from the player.
  - <tt>magic</tt> (number): number of magic points to remove

- <tt>game:start_decreasing_magic(delay)</tt>:
Starts removing magic points continuously.
Only possible when the game is running.
  - <tt>delay</tt> (number): delay in milliseconds between each loss of 1
    point

- <tt>game:stop_decreasing_magic()</tt>:
Stops removing magic points continuously.
Only possible when the game is running.

- <tt>game:get_max_magic()</tt>:
Returns the maximum number of magic points.
  - Return value (number): the maximum number of magic points

- <tt>game:set_max_magic(magic)</tt>:
Sets the maximum number of magic points.
  - <tt>magic</tt> (number): the maximum number of magic points to set

- <tt>game:has_ability(ability_name)</tt>:
Returns whether the player has an ability.
Equivalent to <tt>game:get_ability(ability_name) > 0</tt>.
  - <tt>ability_name</tt>: name of the ability to get (must be a valid
    built-in ability name)
  - Return value (boolean): true if the player has this ability

- <tt>game:get_ability(ability_name)</tt>:
Returns the level of an ability.
  - <tt>ability_name</tt> (string): name of the ability to get (must be a valid
    built-in ability name)
  - Return value (number): level of this ability
    (0 means not having this ability yet)

- <tt>game:set_ability(ability_name, level)</tt>:
Sets the level of an ability.
  - <tt>ability_name</tt> (string): name of the ability to set (must be a valid
    built-in ability name)
  - <tt>level</tt> (number): level of this ability to set
    (0 removes the ability)

- <tt>game:has_item(item_name)</tt>:
Returns whether the player has an item.
Equivalent to <tt>game:get_item(item_name) > 0</tt>.
  - <tt>item_name</tt> (string): name of the item to get (must be an item
    defined in <tt>items.dat</tt>)
  - Return value (boolean): true if the player has this item

- <tt>game:get_item(item_name)</tt>:
Returns the possession state (variant) of an item.
  - <tt>item_name</tt> (string): name of the item to get (must be an item
    defined in <tt>items.dat</tt>)
  - Return value (number): the variant of this item possessed by the player
    (0 means not having this item yet, 1 means the first variant, etc.)

- <tt>game:set_item(item_name, variant)</tt>:
Sets the possession state (variant) of an item.
  - <tt>item_name</tt> (string): name of the item to set (must be an item
    defined in <tt>items.dat</tt>)
  - <tt>variant</tt> (number): the variant of this item possessed by the player
    (0 means not having this item yet, 1 means the first variant, etc.)

- <tt>game:has_item_amount(item_name, amount)</tt>:
Returns whether the player has at least the specified amount of an item.
The item must have a counter (i.e. a notion of amount).
Equivalent to <tt>game:get_item_amount(item_name) > 0</tt>.
  - <tt>item_name</tt> (string): name of the item to get (the item must
    have a counter)
  - <tt>amount</tt> (number): the amount to check
  - Return value (boolean): true if the player has at least this amount of the
    item

- <tt>game:get_item_amount(item_name)</tt>:
Returns the amount the player has for an item.
The item must have a counter (i.e. a notion of amount).
  - <tt>item_name</tt> (string): name of the item to get (the item must
    have a counter)
  - Return value (number): the amount of this item

- <tt>game:add_item_amount(item_name, amount)</tt>:
Adds an amount of the specified item.
The item must have a counter (i.e. a notion of amount).
  - <tt>item_name</tt> (string): name of the item to get (the item must
    have a counter)
  - <tt>amount</tt> (number): the amount to add

- <tt>game:remove_item_amount(item_name, amount)</tt>:
Removes an amount of the specified item.
The item must have a counter (i.e. a notion of amount).
  - <tt>item_name</tt> (string): name of the item to get (the item must
    have a counter)
  - <tt>amount</tt> (number): the amount to remove

- <tt>game:is_dungeon_finished(dungeon)</tt>:
Returns whether the specified dungeon is finished.
  - <tt>dungeon</tt> (number): id of the dungeon to get (the first one is 1)
  - Return value (boolean): true if this dungeon is finished

- <tt>game:set_dungeon_finished(dungeon)</tt>:
Sets the specified dungeon as finished.
  - <tt>dungeon</tt> (number): id of the dungeon to get (the first one is 1)

@subsection sol.map Module <tt>sol.map</tt>

The <tt>sol.map</tt> module is available to scripts attached to a map.
<tt>sol.map</tt> can be seen as an object that represents the current map
and the elements displayed with it.
Most of the functions provided here apply to an entity of the map (possibly the hero)
and are prefixed by the type of entity.

- <tt>sol.map.dialog_start(dialog_id)</tt>:
Show a dialog box.

- <tt>sol.map.dialog_set_variable(dialog_id, value)</tt>:
Specifies a value to display inside a dialog (for example the
player's name). In this dialog, the sequence <tt>$v</tt> will
be substituted by this value.

- <tt>sol.map.dialog_set_style(style)</tt>:
Sets the style of the dialog box for subsequent dialogs (0: usual dialog box,
1: no dialog box, only display the text)

- <tt>sol.map.hud_set_pause_enabled(bool enabled)</tt>:
Allows or disallows to pause the game (and thus to save the game).

- <tt>sol.map.hud_set_enabled(enabled)</tt>:
Hides or restores the HUD (the player can still use his items
and pause the game).

- <tt>sol.map.light_get()</tt>:
returns the current light level of the map

- <tt>sol.map.light_set(light_level)</tt>:
sets the light level of the map (0: no light, positive values: full light)

- <tt>sol.map.camera_move(x, y, speed, function, delay_before, delay_after)</tt>:
moves the camera to a target point (a usual speed value is 250),
waits a delay in milliseconds (default is 1000), calls a function,
waits another delay (default is 1000) and restores the camera;
the game is suspended during the whole sequence

- <tt>sol.map.tileset_get()</tt>:
returns the id of the tileset of this map

- <tt>sol.map.tileset_set(tileset_id)</tt>:
Changes the tileset used to draw the map.
The new tileset must be compatible with the previous one,
i.e. every tile of the previous tileset must exist in the new one
and have the same properties.
This function keeps the tiles of the previous tileset and loads the
image of the new tileset.

- <tt>sol.map.sprite_display(sprite, x, y)</tt>:
Displays a sprite at the given position (relative to the the map top-left
corner). The origin point of the sprite will be displayed at this location.

- <tt>sol.map.treasure_give(item_name, variant, savegame_variable)</tt>:
gives a treasure to the player (without using a chest)

- <tt>sol.map.hero_freeze()</tt>:
prevents the hero from moving until you call <tt>sol.map.hero_unfreeze()</tt>

- <tt>sol.map.hero_unfreeze()</tt>:
restores the control to the hero, typically after a call to <tt>sol.map.hero_freeze()</tt>

- <tt>sol.map.hero_set_map(map_id, destination_point, transition)</tt>:
Sends the hero on a map (possibly the same one), see Transition::Style for the values of transition.

- <tt>sol.map.hero_set_visible(visible)</tt>:
Hides or unhides the hero. The player can continue to control him even if
he is invisible.

- <tt>sol.map.hero_get_direction()</tt>:
Returns the direction of the hero's sprites (0 to 3).

- <tt>sol.map.hero_set_direction(direction4)</tt>:
Sets the direction of the hero's sprites (0 to 3).

- <tt>sol.map.hero_get_position()</tt>:
Returns the coordinates and the layer of the hero (3 return values).

- <tt>sol.map.hero_set_position(x, y, layer)</tt>:
Sets the coordinates and the layer of the hero.
The layer is optional: by default, it is unchanged.

- <tt>sol.map.hero_align_on_sensor(sensor_name)</tt>:
places the hero's bounding box exactly on the rectangle of a sensor

- <tt>sol.map.hero_save_solid_ground(x, y, layer)</tt>:
Memorizes a position to go back to if the hero falls into a hole or other bad
ground. This replaces the usual behavior which is going back to the previous
solid position just before falling.
The arguments are optional: by default, they correspond to the current
position of the hero. But if you provide them, you must set all three of them,
otherwise they are ignored.

- <tt>sol.map.hero_reset_solid_ground()</tt>:
Forgets a position that was previously memorized by
<tt>sol.map.hero_set_solid_ground()</tt> (if any).
The usual behavior is restored: the hero will now just get
back to where he was just before falling, instead going to of a memorized
position.

- <tt>sol.map.hero_walk(path, loop, ignore_obstacles)</tt>:
Makes the hero move with the specified path and a walking animation.
The player cannot control him during the movement.

- <tt>sol.map.hero_start_jumping(direction8, length, ignore_obstacles)</tt>:
makes the hero jump towards the specified direction (0 to 7)

- <tt>sol.map.hero_start_victory_sequence()</tt>:
Makes the hero brandish his sword for a victory.
When the animation finishes,
<tt>event_hero_victory_sequence_finished</tt> will be called in the map script.

- <tt>sol.map.hero_start_boomerang(max_distance, speed, tunic_preparing_animation, sprite_name)</tt>:
Makes the hero throw a boomerang.
<tt>tunic_preparing_animation</tt> is the name of the animation that the
hero's tunic sprite should take while preparing the boomerang.
<tt>sprite_name</tt> is the animation set id to use to draw the boomerang then.

- <tt>sol.map.hero_start_bow()</tt>:
makes the hero shoot an arrow

- <tt>sol.map.hero_start_running()</tt>:
makes the hero run

- <tt>sol.map.hero_start_hurt(source_x, source_y, life_points, magic_points)</tt>:
Hurts the hero. The number of life points will be reduced with the tunic level.

- <tt>sol.map.npc_is_enabled(npc_name)</tt>:
returns whether an NPC is enabled

- <tt>sol.map.npc_set_enabled(npc_name, enable)</tt>:
enables or disables an NPC

- <tt>sol.map.npc_set_group_enabled(npc_prefix, enable)</tt>:
enables or disables all NPCs having a common prefix

- <tt>sol.map.npc_get_position(npc)</tt>:
Returns the position of an NPC (x, y and layer).

- <tt>sol.map.npc_set_position(npc, x, y, layer)</tt>:
Sets the position of an NPC. The layer is optional
(by default, it is unchanged).

- <tt>sol.map.npc_start_movement(npc, movement)</tt>:
starts a movement on an NPC

- <tt>sol.map.npc_stop_movement(npc, movement)</tt>:
stops the movement of an NPC

- <tt>sol.map.npc_get_sprite(npc)</tt>:
Returns the sprite of an NPC. Your script can then use the
<tt>sol.main.sprite_*</tt> functions on it.

- <tt>sol.map.npc_remove(npc)</tt>:
removes an NPC from the map

- <tt>sol.map.npc_exists(npc)</tt>:
checks the existence of an NPC

- <tt>sol.map.chest_is_open(chest_name)</tt>:
returns the state of a chest

- <tt>sol.map.chest_set_open(chest_name, open)</tt>:
sets the state of a chest (without giving or reseting its content)

- <tt>sol.map.chest_is_enabled(chest_name)</tt>:
returns whether a chest is enabled

- <tt>sol.map.chest_set_enabled(chest_name, enable)</tt>:
enables or disables a chest

- <tt>sol.map.chest_set_group_enabled(chests_prefix, enable)</tt>:
enables or disables all chests having a common prefix

- <tt>sol.map.tile_is_enabled(tile_name)</tt>:
returns whether a dynamic tile is enabled

- <tt>sol.map.tile_set_enabled(tile_name, enable)</tt>:
enables or disables a dynamic tile

- <tt>sol.map.tile_set_group_enabled(tiles_prefix, enable)</tt>:
enables or disables all dynamic tiles having a common prefix

- <tt>sol.map.stairs_is_enabled(stairs_name)</tt>:
returns whether some stairs are enabled

- <tt>sol.map.stairs_set_enabled(stairs_name, enable)</tt>:
enables or disables some stairs

- <tt>sol.map.stairs_set_group_enabled(stairs_prefix, enable)</tt>:
enables or disables all stairs having a common prefix

- <tt>sol.map.obstacle_is_enabled(custom_obstacle_name)</tt>:
returns whether a custom obstacle is enabled

- <tt>sol.map.obstacle_set_enabled(custom_obstacle_name, enable)</tt>:
enables or disables a custom obstacle

- <tt>sol.map.obstacle_set_group_enabled(custom_obstacles_prefix, enable)</tt>:
enables or disables all custom obstacles having a common prefix

- <tt>sol.map.sensor_is_enabled(sensor_name)</tt>:
returns whether a sensor is enabled

- <tt>sol.map.sensor_set_enabled(sensor_name, enable)</tt>:
enables or disables a sensor

- <tt>sol.map.sensor_set_group_enabled(sensors_prefix, enable)</tt>:
enables or disables all sensors having a common prefix

- <tt>sol.map.jumper_is_enabled(jumper_name)</tt>:
returns whether a jumper is enabled

- <tt>sol.map.jumper_set_enabled(jumper_name, enable)</tt>:
enables or disables a jumper

- <tt>sol.map.jumper_set_group_enabled(jumpers_prefix, enable)</tt>:
enables or disables all jumpers having a common prefix

- <tt>sol.map.crystal_is_enabled(crystal_name)</tt>:
returns whether a crystal is enabled (i.e. whether it is visible)  

- <tt>sol.map.crystal_set_enabled(crystal_name, enable)</tt>:
enables or disables a crystal

- <tt>sol.map.crystal_set_group_enabled(crystals_prefix, enable)</tt>:
enables or disables all crystals having a common prefix

- <tt>sol.map.crystal_get_state()</tt>
returns the state of crystal blocks (false: initial, true: modified)

- <tt>sol.map.crystal_set_state(state)</tt>
sets the state of crystal blocks (false: initial, true: modified)

- <tt>sol.map.crystal_change_state()</tt>
inverts the state of crystal blocks

- <tt>sol.map.teletransporter_is_enabled(teletransporter_name)</tt>:
returns whether a teletransporter is enabled

- <tt>sol.map.teletransporter_set_enabled(teletransporter_name, enable)</tt>:
enables or disables a teletransporter

- <tt>sol.map.teletransporter_set_group_enabled(teletransporters_prefix, enable)</tt>:
enables or disables all teletransporters having a common prefix

- <tt>sol.map.block_is_enabled(block_name)</tt>:
returns whether a block is enabled

- <tt>sol.map.block_set_enabled(block_name, enable)</tt>:
enables or disables a block

- <tt>sol.map.block_set_group_enabled(blocks_prefix, enable)</tt>:
enables or disables all blocks having a common prefix

- <tt>sol.map.block_reset(block_name)</tt>:
places a block where it was when the map started

- <tt>sol.map.block_reset_all()</tt>:
resets all blocks of the map

- <tt>sol.map.block_get_position(block_name)</tt>:
Returns the position of a block (3 return values: x, y, layer).

- <tt>sol.map.block_set_position(block_name, x, y, layer)</tt>:
Sets the position of a block.
The layer is optional (by default, it is unchanged).

- <tt>sol.map.shop_item_exists(shop_item_name)</tt>:
Returns whether a shop item exists on the map.

- <tt>sol.map.shop_item_remove(shop_item_name)</tt>:
Removes a shop item from the map if it exists.

- <tt>sol.map.switch_is_activated(switch_name)</tt>:
returns whether a switch is activated

- <tt>sol.map.switch_set_activated(switch_name, activated)</tt>:
activates or inactivates a switch

- <tt>sol.map.switch_set_locked(switch_name, locked)</tt>:
locks a switch in its current state or unlocks it

- <tt>sol.map.switch_is_enabled(switch_name)</tt>:
returns whether a switch is enabled (i.e. visible)

- <tt>sol.map.switch_set_enabled(switch_name, enable)</tt>:
enables or disables a switch

- <tt>sol.map.switch_set_group_enabled(switches_prefix, enable)</tt>:
enables or disables all switches having a common prefix

- <tt>sol.map.door_open(door_prefix)</tt>:
Opens one or several doors, playing their animation and sound.
If some doors with this prefix are already open, nothing happens for them.

- <tt>sol.map.door_close(door_prefix)</tt>:
Closes one or several doors, playing their animation and sound.
Nothing happens if some doors with this prefix are already closed.

- <tt>sol.map.door_is_open(door_name)</tt>:
returns whether a door is open

- <tt>sol.map.door_set_open(door_name, open)</tt>:
changes immediately the state of a door (without playing animation and sound)

- <tt>sol.map.pickable_item_create(item_name, variant, savegame_variable, x, y, layer)</tt>:
creates a pickable item and places it on the map

- <tt>sol.map.destructible_item_create(subtype, x, y, layer, properties)</tt>:
Creates a destructible item and places it on the map.
<tt>subtype</tt> can be "pot", "bush", "white_stone", "black_stone", "grass"
or "bomb_flower".
<tt>properties</tt> is optional. If provided, it is a table
whose key-value pairs can be:
  - <tt>treasure_name</tt> (string, default "_random"): treasure under the
    destructible item, can also be "_none" or "_random",
  - <tt>treasure_variant</tt> (integer, default 1): variant of this treasure,
  - <tt>treasure_savegame_variable</tt> (integer, default -1): savegame
    variable of this treasure (-1 means not saved),
  - <tt>destruction_callback</tt> (function, default nil): a function that will
    be called when the destructible item is destroyed.

- <tt>sol.map.block_create(x, y, layer, name, properties)</tt>:
Creates a block and places it on the map.
<tt>properties</tt> is optional. If provided, it is a table
whose key-value pairs can be:
  - <tt>direction</tt> (integer, 0 to 3 or -1 to allow the block to move in any direction (default is -1)),
  - <tt>sprite_name</tt> (string, default "entities/block"),
  - <tt>can_be_pushed</tt> (boolean, default true),
  - <tt>can_be_pulled</tt> (boolean, default false),
  - <tt>maximum_moves</tt> (integer: 0 for no
move, 1 for one move only (default), 2 for infinite moves)

- <tt>sol.map.bomb_create(x, y, layer)</tt>:
creates a bomb and places it on the map

- <tt>sol.map.explosion_create(x, y, layer)</tt>:
creates an explosion on the map

- <tt>sol.map.fire_create(x, y, layer)</tt>:
creates some fire on the map

- <tt>sol.map.arrow_remove()</tt>
removes any arrow currently thrown on the map

- <tt>sol.map.enemy_create(enemy_name, breed, layer, x, y)</tt>:
Creates an enemy on the map.

- <tt>sol.map.enemy_remove(enemy_name)</tt>:
Removes an enemy from the map.

- <tt>sol.map.enemy_remove_group(enemies_name_prefix)</tt>:
Removes a group of enemies from the map.

- <tt>sol.map.enemy_is_enabled(enemy_name)</tt>:
returns whether an enemy is enabled

- <tt>sol.map.enemy_set_enabled(enemy_name, enable)</tt>:
enables or disables an enemy

- <tt>sol.map.enemy_set_group_enabled(enemies_prefix, enable)</tt>:
enables or disables all enemies having a common prefix

- <tt>sol.map.enemy_is_dead(enemy_name)</tt>:
returns whether an enemy is dead

- <tt>sol.map.enemy_is_group_dead(enemies_name_prefix)</tt>:
returns whether all enemies having a common prefix are dead

- <tt>sol.map.enemy_get_group_count(enemies_name_prefix)</tt>:
Returns the number of living enemies of the map whose name starts with the specified prefix.

- <tt>sol.map.enemy_get_position(enemy_name)</tt>:
Returns the current position of an enemy on the map.
Three values are returned: x, y and the layer (0 to 2).

- <tt>sol.map.enemy_set_position(enemy_name, x, y, layer)</tt>:
Sets the positions of an enemy on the map. The layer is optional:
by default, it is unchanged.

- <tt>sol.map.enemy_set_treasure(enemy_name, item_name, variant, savegame_variable)</tt>:
Sets the treasure of an enemy.

- <tt>sol.map.enemy_set_no_treasure(enemy_name)</tt>:
Sets no treasure for an enemy.

- <tt>sol.map.enemy_set_random_treasure(enemy_name)</tt>:
Sets a random treasure for an enemy.

- <tt>sol.map.enemy_get_sprite(enemy_name)</tt>:
Returns the sprite of an enemy (if the enemy has several sprites, the first
one created is returned)

@subsection sol.item Module <tt>sol.item</tt>

The <tt>sol.item</tt> module is available to scripts attached to an item defined in the <tt>items.dat</tt> file.
<tt>sol.item</tt> can be seen as an object that represents a particular item of the equipment.
Depending on the current context, <tt>sol.item</tt> may additionally represent an instance of pickable item present on the map
or an instance of inventory item currently being used by the hero.

- <tt>sol.item.get_variant()</tt>:
returns the possession state of the item controlled by this script (0: not possessed, 1: first variant, 2: second variant, etc.)

- <tt>sol.item.set_variant(variant)</tt>:
sets the possession state of the item controlled by this script (0: not possessed, 1: first variant, 2: second variant, etc.)

- <tt>sol.item.get_amount()</tt>:
returns the amount of the item controlled by this script (only for an item with amount)

- <tt>sol.item.set_amount(amount)</tt>:
sets the amount of the item controlled by this script (only for an item with a counter)

- <tt>sol.item.add_amount(amount)</tt>:
increases the amount of the item controlled by this script (only for an item with a counter)

- <tt>sol.item.remove_amount(amount)</tt>:
decreases the amount of the item controlled by this script (only for an item with a counter)

- <tt>sol.item.get_sprite()</tt>:
returns the sprite representing the current pickable item
(can be called only when there is a current pickable item in the context)

- <tt>sol.item.get_movement()</tt>:
returns the movement of the current pickable item
(can be called only when there is a current pickable item in the context)

- <tt>sol.item.start_movement(movement)</tt>:
gives another movement to the current pickable item instead of the default one
(can be called only when there is a current pickable item in the context)

- <tt>sol.item.get_position()</tt>:
Returns the position of the current pickable item (returns x, y and the layer).
Can be called only when there is a current pickable item in the context.

- <tt>sol.item.set_position(x, y, layer)</tt>:
Sets the position of the current pickable item.
The layer is optional: by default, it is unchanged.
Can be called only when there is a current pickable item in the context.

- <tt>sol.item.set_layer_independent_collisions(independent)</tt>:
sets whether the collisions with the current pickable item should be detected
from every layer
(can be called only when there is a current pickable item in the context)

- <tt>sol.item.set_finished()</tt>:
notifies the hero that he has finished using the current inventory item and can get back to a normal state
(can be called only when the hero is currently using the inventory item controlled by this script)

@subsection sol.main Module <tt>sol.enemy</tt>

The <tt>sol.enemy</tt> module is available to scripts attached to an enemy.
<tt>sol.enemy</tt> represents a particular instance of enemy.
Each breed of enemy is controlled by a Lua script.
If several enemies of the same breed exist on the map, they all have their
own Lua world, which means they don't share global values.

- <tt>sol.enemy.get_name()</tt>:
returns the name of the current enemy

- <tt>sol.enemy.get_life()</tt>:
returns the current level of life of the enemy

- <tt>sol.enemy.set_life(life)</tt>:
sets the level of life of the enemy
(default is 1 when the enemy is created)

- <tt>sol.enemy.add_life(life)</tt>:
adds some life to the enemy

- <tt>sol.enemy.remove_life(life)</tt>:
remove some life from the enemy

- <tt>sol.enemy.get_damage()</tt>:
returns the number of life points that the enemy removes from the hero when touching him
(when the hero's defense level is minimal)

- <tt>sol.enemy.set_damage(damage)</tt>:
sets the number of life points that the enemy removes from the hero when touching him
(when the hero's defense level is minimal)
(default is 1)

- <tt>sol.enemy.get_magic_damage()</tt>:
returns the number of magic points that the enemy removes from the hero when touching him

- <tt>sol.enemy.set_magic_damage(magic_damage)</tt>:
sets the number of magic points that the enemy removes from the hero when touching him
(default is 0)

- <tt>sol.enemy.is_pushed_back_when_hurt()</tt>:
returns whether the enemy is pushed away when it is hurt

- <tt>sol.enemy.set_pushed_back_when_hurt(pushed_back_when_hurt)</tt>:
sets whether the enemy is pushed away when it is hurt
(default is true)

- <tt>sol.enemy.get_push_hero_on_sword()</tt>:
returns whether the hero is pushed away when he strikes the enemy with the sword

- <tt>sol.enemy.set_push_hero_on_sword(push_hero_on_sword)</tt>:
sets whether the hero is pushed away when he strikes the enemy with the sword
(default is false)

- <tt>sol.enemy.get_can_hurt_hero_running(can_hurt_hero_running)</tt>:
returns whether the enemy can hurt the hero even when the hero is running

- <tt>sol.enemy.set_can_hurt_hero_running(can_hurt_hero_running)</tt>:
sets whether the enemy can hurt the hero even when the hero is running
(default is false)

- <tt>sol.enemy.get_hurt_style()</tt>:
returns the style of sounds and animations to play when the enemy is hurt:
"normal", "monster" or "boss"

- <tt>sol.enemy.set_hurt_style(style)</tt>:
sets the style of sounds and animations to play when the enemy is hurt:
"normal", "monster" or "boss" (default is "normal" for usual enemies
and "boss" for bosses and minibosses)

- <tt>sol.enemy.get_can_attack()</tt>:
returns whether the enemy can currently attack the hero

- <tt>sol.enemy.set_can_attack(can_attack)</tt>:
Sets whether the enemy can currently attack the hero (default is true).
When the enemy restarts after being hurt, <tt>can_attack</tt> is always
reset to true.

- <tt>sol.enemy.get_minimum_shield_needed()</tt>:
returns the minimum hero's level of shield that allows him to stop attacks from this enemy
(0 means that he cannot stop the attacks)

- <tt>sol.enemy.set_minimum_shield_needed(shield_level)</tt>:
returns the minimum hero's level of shield that allows him to stop attacks from this enemy
(0 means that he cannot stop the attacks and is the default)

- <tt>sol.enemy.set_attack_consequence(attack, consequence)</tt>:
Sets how the enemy reacts when it receives an attack.
<tt>attack</tt> can be "sword", "thrown_item", "explosion",
"arrow", "hookshot", "boomerang", or "fire".
<tt>consequence</tt> can be an integer that indicates the number
of life points to remove, or the string
"ignored", "protected", "immobilize" or "custom".
This reaction will be applied unless the sprite that receives the attack
has a specific reaction (see <tt>sol.enemy.set_attack_consequence_sprite</tt>). 

- <tt>sol.enemy.set_attack_consequence_sprite(sprite, attack, consequence)</tt>:
Sets how the enemy reacts when a particular sprite receives an attack.
<tt>attack</tt> and <tt>consequence</tt> can have the same values
as <tt>sol.enemy.set_attack_consequence</tt>.

- <tt>sol.enemy.set_default_attack_consequences()</tt>:
Sets the default attack consequences for the enemy.

- <tt>sol.enemy.set_default_attack_consequences_sprite(sprite)</tt>:
Sets the default attack consequences for a particular sprite of the enemy.

- <tt>sol.enemy.set_invincible()</tt>:
Makes the enemy ignore all attacks.
Equivalent to calling <tt>sol.enemy.set_attack_consequence(attack,
"ignored")</tt> for each attack.

- <tt>sol.enemy.set_invincible_sprite(sprite)</tt>:
Makes a particular sprite of the enemy ignore all attacks.
Equivalent to calling <tt>sol.enemy.set_attack_consequence_sprite(sprite,
attack, "ignored")</tt> for each attack.

- <tt>sol.enemy.set_layer_independent_collisions(independent)</tt>:
Sets whether the collisions with the enemy should be detected
from every layer (default is false).

- <tt>sol.enemy.set_treasure(item_name, variant, savegame_variable)</tt>:
Sets the treasure of the enemy.
<tt>item_name</tt> can be the name of a valid item, "_none"
or "_random".
<tt>savegame_variable</tt> can be -1 if you don't want the item
to be saved.

- <tt>sol.enemy.set_no_treasure()</tt>:
Sets no treasure of the enemy.
Equivalent to <tt>sol.enemy.set_treasure("_none", 1, -1)</tt>.

- <tt>sol.enemy.set_random_treasure()</tt>:
Sets a random treasure for the enemy (this is the default behavior).
Equivalent to <tt>sol.enemy.set_treasure("_random", 1, -1)</tt>.

- <tt>sol.enemy.get_obstacle_behavior()</tt>:
Returns how the enemy behaves with obstacles: "normal", "flying" or "swimming".

- <tt>sol.enemy.set_obstacle_behavior(behavior)</tt>:
Sets how the enemy behaves with obstacles: "normal", "flying" or "swimming".
"flying" will ignore obstacles like holes, water or lava.
"swimming" will ignore water.

- <tt>sol.enemy.get_optimization_distance(distance)</tt>:
Returns the optimization threshold. Above this distance from the visible area
of the map, the enemy will be suspended.
A value of 0 means an infinite distance (the enemy is never optimized away).

- <tt>sol.enemy.set_optimization_distance(distance)</tt>:
Sets the optimization threshold. Above this distance from the visible area
of the map, the enemy will be suspended. The default value is usually fine,
but you may need to increase it in some cases, for example for a boss in a
huge room. A value of 0 means an infinite distance (the enemy is never
optimized away).

- <tt>sol.enemy.get_size()</tt>:
Returns the size of the enemy's bounding box (two return values: width and height in pixels).

- <tt>sol.enemy.set_size(width, height)</tt>:
Sets the size of the enemy's bounding box (default: 16, 16).
This is the effective size used to detect obstacles when moving,
but the sprite of the enemy may be larger, especially for a boss.

- <tt>sol.enemy.get_origin()</tt>:
Returns the coordinates of the origin point of the enemy, relative to its
bounding box top-left corner (two returns values: x and y).

- <tt>sol.enemy.set_origin(x, y)</tt>:
Sets the coordinates of the origin point of the enemy, relative to its
bounding box top-left corner (default: 0, 0).

- <tt>sol.enemy.get_position()</tt>:
Returns the current position of the enemy on the map
(i.e. the position of its origin point relative to the map's top-left corner).
Three values are returned: x, y and the layer.

- <tt>sol.enemy.set_position(x, y, layer)</tt>:
Sets the position of the enemy on the map
(i.e. the position of its origin point relative to the map's top-left corner).
The layer is optional: by default, is is unchanged.

- <tt>sol.enemy.get_distance_to_hero()</tt>:
Returns the distance in pixels between the enemy and the hero.

- <tt>sol.enemy.get_angle_to_hero()</tt>:
Returns the angle in radians of the vector from the enemy to the hero.

- <tt>sol.enemy.test_obstacles(dx, dy)</tt>:
Returns whether there would be a collision if the enemy was translated
with the given parameters.

- <tt>sol.enemy.snap_to_grid()</tt>:
Makes sure the enemy's top-left corner is aligned with the 8*8 grid of the map.
Be careful: this function does not check collisions with obstacles.

- <tt>sol.enemy.get_movement()</tt>:
Returns the current movement of the enemy.

- <tt>sol.enemy.start_movement(movement)</tt>:
Sets a movement to the enemy (any previous movement is destroyed).

- <tt>sol.enemy.stop_movement()</tt>:
Stops and destroys the current movement of the enemy (if any).

- <tt>sol.enemy.restart()</tt>:
Restarts the enemy. This plays animation "walking" on its sprites
and triggers event_restart().

- <tt>sol.enemy.hurt(life_points)</tt>:
Hurts the enemy.

- <tt>sol.enemy.create_sprite(animation_set)</tt>:
Creates a sprite attached to the enemy and returns it.

- <tt>sol.enemy.remove_sprite(sprite)</tt>:
Removes and destroys a sprite of this enemy. If <tt>sprite</tt> is not
specified, the first sprite that was created is removed.

- <tt>sol.enemy.get_sprite()</tt>:
Returns the sprite of the enemy. If the enemy has several sprites, the first
one that was created is returned.
If you have created several sprites, this function is probably not for you:
you should memorize the return value of each call to
<tt>sol.enemy.create_sprite</tt> instead.

- <tt>sol.enemy.create_son(enemy_name, breed, x, y, layer)</tt>:
Creates another enemy, specifying its coordinates as relative to the current
enemy. The layer is optional: by default, the enemy is created on the same
layer as the current one.

- <tt>sol.enemy.get_father()</tt>:
Returns the name of the father of the enemy (if any).
The father is the enemy that created
the current one by calling <tt>sol.enemy.create_son</tt>,
Returns an empty string if the current enemy has no father.

- <tt>sol.enemy.send_message(dst_enemy, message)</tt>:
Sends a string message to another enemy.
His function event_message_received() will be called,
and then <tt>sol.enemy.send_message</tt> will return.

@subsection sol.movement Module <tt>sol.movement</tt>

This module provides functions to create movements and manage their
properties. It is available to all scripts.
When you create a movement, you get a value of type movement with several
methods available.

- <tt>sol.movement.pixel_movement_create(trajectory, delay)</tt>:
Creates a movement that follows a pixel precise trajectory.
  - <tt>trajectory</tt> (string): the whole trajectory, with the
    syntax "dx1 dy1 dx2 dy2 dx3 dy3 ..."
  - <tt>delay</tt> (number): delay in milliseconds between two translations
  - Return value (movement): the movement created

- <tt>sol.movement.random_movement_create(speed)</tt>:
Creates a movement that goes in random directions.
  - <tt>speed</tt> (number): speed in pixels per second
  - Return value (movement): the movement created

- <tt>sol.movement.path_movement_create(path, speed)</tt>:
Creates a movement composed of a specified sucession of movements of 8 pixels
  - <tt>path</tt> (string): the succession of basic moves (each character
    represents a direction between '0' and '7')
  - <tt>speed</tt> (number): speed in pixels per second
  - Return value (movement): the movement created

- <tt>sol.movement.random_path_movement_create(speed)</tt>:
Creates a movement composed of random successions of movements of 8 pixels
  - <tt>speed</tt> (number): speed in pixels per second
  - Return value (movement): the movement created

- <tt>sol.movement.path_finding_movement_create(speed)</tt>:
Creates a movement that calculates a path to the hero.
  - <tt>speed</tt> (number): speed in pixels per second
  - Return value (movement): the movement created

- <tt>sol.movement.target_movement_create(speed, target_x, target_y)</tt>:
Creates a movement that goes towards the hero or a fixed point.
If <tt>target_x</tt> and <tt>target_y</tt> are unspecified, the movement tracks
the hero and updates itself when the hero moves.
  - <tt>speed</tt> (number): speed in pixels per second
  - <tt>target_x</tt> (number, optional): x cordinate of a fixed point to target
  - <tt>target_y</tt> (number, optional): y cordinate of a fixed point to target
  - Return value (movement): the movement created

- <tt>sol.movement.straight_movement_create(speed, angle)</tt>:
Creates a rectilinear movement.
  - <tt>speed</tt> (number): speed in pixels per second
  - <tt>angle</tt> (number): angle in radians
  - Return value (movement): the movement created

- <tt>sol.movement.circle_movement_create(center_type, center_name, radius)</tt>:
Creates a circular movement around a map entity.
TODO: change the prototype to make it easier to use and allow to specify a fixed point
  - <tt>center_type</tt> (number): type of the center entity (see the
    EntityType enum)
  - <tt>center_name</tt> (string): name of the center entity
  - <tt>radius</tt> (number): radius of circles to make in pixels
  - Return value (movement): the movement created

- <tt>sol.movement.jump_movement_create(direction, length)</tt>:
Creates a jump movement.
  - <tt>direction</tt> (number): direction of the jump (0 to 7)
  - <tt>length</tt> (number): length of the jump in pixels
  - Return value (movement): the movement created

- <tt>movement:get_property(key)</tt>:
Returns a string property from this movement (warning: it always returns a string!).
  - <tt>key</tt> (string): name of the property to get
  - Return value (string): the value of this property

- <tt>movement:set_property(key, value)</tt>:
Sets a property of this movement.
  - <tt>key</tt> (string): name of the property to set
  - <tt>value</tt> (string, number or boolean): the value to set

- <tt>movement:test_obstacles(dx, dy)</tt>:
Tests whether there would be a collision if the map entity controlled by this
movement was translated with the given parameters.
  - <tt>dx</tt> (number): x translation in pixels
  - <tt>dy</tt> (number): y translation in pixels


@subsection sol.sprite Module <tt>sol.sprite</tt>

Your script can create sprites or access existing ones
(e.g. a sprite attached to an NPC).
In both cases, the following methods are available on the type
<tt>sprite</tt>.

- <tt>sol.sprite.create(sprite_name)</tt>:
Creates a sprite.
  - <tt>sprite_name</tt> (string): name of the animation set to use
  - Return value (sprite): the sprite created

- <tt>sprite:get_animation()</tt>:
Returns the name of the current animation of this sprite.
  - Return value (string): name of the current animation

- <tt>sprite:set_animation(animation_name)</tt>:
Sets the current animation of this sprite.
  - <tt>animation_name</tt> (string): name of the animation to set

- <tt>sprite:get_direction()</tt>:
Returns the current direction of this sprite.
  - Return value (number): the current direction
    (<tt>0</tt> to <tt>nb_directions-1</tt>)

- <tt>sprite:set_direction(direction)</tt>:
Sets the current direction of this sprite.
  - <tt>direction</tt> (number): the direction to set
    (<tt>0</tt> to <tt>nb_directions-1</tt>)

- <tt>sprite:get_frame()</tt>:
Returns the index of the current frame of this sprite.
  - Return value (number): the current frame
    (<tt>0</tt> to <tt>nb_frames-1</tt>)

- <tt>sprite:set_frame(frame)</tt>:
Sets the current frame of this sprite.
  - <tt>frame</tt> (number) the frame to set
    (<tt>0</tt> to <tt>nb_frames-1</tt>)

- <tt>sprite:get_frame_delay()</tt>:
Returns the delay between two frames of this sprite.
  - Return value (number): the delay in milliseconds between two frames

- <tt>sprite:set_frame_delay(delay)</tt>:
Sets the delay between two frames of this sprite.
  - <tt>delay</tt> (number): the delay to set in millisecons

- <tt>sprite:is_paused()</tt>:
Returns whether this sprite is paused.
  - Return value (boolean): true if this sprite is paused

- <tt>sprite:set_paused(paused)</tt>:
Pauses or resumes the animation of this sprite.
  - <tt>paused</tt> (boolean): true to pause the sprite, false to unpause it

- <tt>sprite:set_animation_ignore_suspend(ignore)</tt>:
Sets whether the animation should continue even when this sprite is suspended.
  - <tt>ignore</tt> (boolean): true to continue animation even when suspended

- <tt>sprite:fade(direction)</tt>:
Shows a fade effect on this sprite.
  - <tt>direction</tt> (number): 0 for fade-in effect, 1 for a fade-out effect

- <tt>sprite:synchronize(reference_sprite)</tt>:
Synchronizes the frames of this sprite with the frames of a reference sprite.
The synchronization will be performed whenever their animation names match.
  - <tt>reference_sprite</tt> (sprite, optional): the reference sprite
    (if <tt>nil</tt>, any previous synchronization is stopped)

@subsection sol.surface Module <tt>sol.surface</tt>

The <tt>sol.surface</tt> module provides the type surface,
which represents a 2D image. You can draw displayable objects
(i.e. other surfaces, text surfaces and sprites) on a surface.

- <tt>sol.surface.create(width, height)</tt>:
Creates an empty surface. The default size is the size of the screen.
  - <tt>width</tt> (number, optional): width of the surface to create in pixels
  - <tt>height</tt> (number, optional): height of the surface to create in pixels
  - Return value (surface): the surface created

- <tt>sol.surface.create(file_name, language_specific)</tt>:
Creates a surface from an image file.
  - <tt>file_name</tt> (string): name of the image file to load
  - <tt>language_specific</tt> (boolean, optional): true to load the image
    from the <tt>images</tt> subdirectory of the current language directory
    (default is false and loads the image from the <tt>sprites</tt> directory)
  - Return value (surface): the surface created

- <tt>sol.surface.create(surface, x, y, width, height)</tt>:
Creates a surface from a region of an existing surface
  - <tt>surface</tt> (surface): an existing surface
  - <tt>x</tt> (integer): x coordinate of the region in pixels
  - <tt>y</tt> (integer): y coordinate of the region in pixels
  - <tt>width</tt> (integer): width of the region in pixels
  - <tt>height</tt> (integer): height of the region in pixels
  - Return value (surface): the surface created

- <tt>surface:get_size()</tt>:
Returns the size of this surface.
  - Return value 1 (number): width of the surface in pixels
  - Return value 2 (number): width of the surface in pixels

- <tt>surface:fill_color(color)</tt>:
Fills this surface with a color.
  - <tt>color</tt> (table): the color as an array of 3 RGB values (0 to 255)

- <tt>surface:draw(displayable, x, y)</tt>:
Draws a displayable object on this surface.
  - <tt>displayable</tt> (surface, text surface or sprite): the displayable
    object to draw on this surface
  - <tt>x</tt> (number, optional): x coordinate of where to draw the object
  - <tt>y</tt> (number, optional): y coordinate of where to draw the object

- <tt>surface:set_transparency_color(color)</tt>:
Sets a transparency color to this surface. Pixels in that color won't be
displayed.
  - <tt>color</tt> (table): the color as an array of 3 RGB values (0 to 255)

- <tt>surface:set_opacity(opacity)</tt>:
Sets the opacity of this surface.
  - <tt>opacity</tt> (integer): the opacity (0 (transparent) to 255 (opaque),
    default is 255)

- <tt>surface:fade_in(delay, callback)</tt>:
Starts a fade-in effect on this surface.
  - <tt>delay</tt> (number, optional): delay in milliseconds between two
    frames of the fade-in animation (default is 20)
  - <tt>callback</tt> (function, optional): a function to call when the
    fade-in effect finishes

- <tt>surface:fade_out(delay, callback)</tt>:
Starts a fade-out effect on this surface.
  - <tt>delay</tt> (number, optional): delay in milliseconds between two
    frames of the fade-out animation (default is 20)
  - <tt>callback</tt> (function, optional): a function to call when the
    fade-out effect finishes

@subsection sol.text_surface Module <tt>sol.text_surface</tt>

<tt>sol.text_surface</tt> provides features to display some text.
The text surface type can be seen as a special surface able to
contain text.

<tt>sol.text_surface.create(properties)</tt>:
Creates a text surface with the specified properties.
  - <tt>properties</tt> (table): a table that describes all properties
    of the text surface to create. Its key-value pairs are all optinoal,
    they can be:
    - <tt>horizontal_alignement</tt> (string, default "left"): "left",
      "center" or "right". When the text surface is displayed at some
      coordinates on a surface, the left/center/right part of the text is
      displayed at those coordinates.
    - <tt>vertical_alignement</tt> (string, default "middle"): "top",
      "middle" or "bottom". When the text surface is displayed at some
      coordinates on a surface, the top/middle/bottom part of the text is
      displayed at those coordinates.
    - <tt>font</tt> (string): name of the font to use (the default is the one
      defined in file <tt>text/fonts.dat</tt>)
    - <tt>rendering_mode</tt> (string, default "solid"): "solid" (normal),
      "shaded" (smooth effect but the text surface won't support transparency,
      a background color will be applied)
      or "blended" (smooth effect keeping transparency, a bit slower)
    - <tt>background_color</tt> (table, default black): a background
      color (array of 3 RGB values between 0 and 255) to apply to the
      text surface (only used in rendering mode "shaded")
    - <tt>text_color</tt> (table, default white): color of the text to display
      (array of 3 RGB values between 0 and 255)
    - <tt>text</tt> (string, default ""): the text to show
      (must be valid UTF-8)
    - <tt>text_key</tt> (string, default nil): key of the localized text
      string to get from the <tt>text/strings.dat</tt> file of the
      current language
    - Return value (text surface): the text surface created

@subsection sol.input Module <tt>sol.input</tt>

This module notifies the script when low-level keyboard or joypad events
occur.
It is only available to scripts of menus because during a game, commands
are already mapped to game features such as using an item, swinging
the sword, talking to an NPC, etc.


@section cpp_to_lua Calling Lua from C++

The C++ engine sometimes notifies a script that an event just happened.
The corresponding event function of the script is called if it exists.
An event function is a Lua function prefixed by <tt>event_</tt>.
We give here the list of event functions that the engine will call if
you define them in your script.
Some events may exist in several types of script.

@subsection events_map Map scripts

- <tt>event_update()</tt>:
called at each cycle (so take care of the performances)

- <tt>event_set_suspended(suspended)</tt>:
called when the game is suspended or resumed

- <tt>event_dialog_started(dialog_id)</tt>:
Called when a dialog box starts, even if the dialog was started by another
script.

- <tt>event_dialog_finished(dialog_id, answer)</tt>:
Called when a dialog finishes (i.e. once its last group of 3 lines is
finished), even if the dialog was started by another script.
If there was a question, answer is 0 if the first answer was chosen,
or 1 if the second one was chosen.
If there was no question, answer is -1.

- <tt>event_camera_back()</tt>: 
Called when the camera (previously sent by <tt>sol.map.camera_move()</tt>)
is back to the hero.

- <tt>event_treasure_obtaining(item_name, variant, savegame_variable)</tt>: 
Called when the player is obtaining a treasure (coming from a chest or not),
just before the dialog starts.

- <tt>event_treasure_obtained(item_name, variant, savegame_variable)</tt>: 
Called when the player has finished obtaining a treasure, just after the
dialog.

- <tt>event_map_started(destination_point_name)</tt>:
called when the map starts, before the opening transition

- <tt>event_map_opening_transition_finished(destination_point_name)</tt>:
called after the opening transition of the map

- <tt>event_switch_activated(switch_name)</tt>:
Called when a switch has just been activated.

- <tt>event_switch_inactivated(switch_name)</tt>:
Called when a switch has just been inactivated.

- <tt>event_switch_left(switch_name)</tt>:
called when an entity placed on a switch (the hero or a block)
has just left the switch, no matter if the switch was activated or not

- <tt>event_hero_victory_sequence_finished()</tt>:
Called when the victory animation of the hero
(started with <tt>sol.map.hero_start_victory_sequence()</tt>)
is finished.

- <tt>event_hero_on_sensor(sensor_name)</tt>:
Called when the hero arrives on a sensor. The bounding box of the hero must
be entirely inside the sensor's bounding box.

- <tt>event_hero_still_on_sensor(sensor_name)</tt>:
Called continuously while the hero is on a sensor.

- <tt>event_npc_interaction(npc_name)</tt>
(triggered only if the NPC has the property to call the map script):
called when the hero interacts with an NPC by pressing the action key

- <tt>event_npc_interaction_finished(npc_name)</tt>:
(triggered only if the NPC has the property to call the map script):
called when the hero has just interacted with an NPC by pressing the action key

- <tt>event_npc_interaction_item(npc_name, item_name, variant)</tt>
(triggered only if the NPC has the property to call the map script):
called when the hero interacts with an NPC by using ANY inventory item;
returns true if an interaction actually happened

- <tt>event_npc_interaction_item_finished(npc_name, item_name, variant)</tt>:
called when the hero has just interacted with an NPC
by using ANY inventory item

- <tt>event_npc_movement_finished(npc_name)</tt>:
called when an NPC has finished its movement

- <tt>event_npc_collision_fire(npc_name)</tt>
(triggered only if the NPC has the property to call the map script):
called when some fire touches an NPC

- <tt>event_sensor_collision_explosion(sensor_name)</tt>:
called when an explosion overlaps a sensor

- <tt>event_chest_empty(chest_name)</tt>:
Called when the hero opens an empty chest.
The hero remains freezed.
Your script has
to define what happens (for example giving a treasure or show
an error message). If you don't give a treasure,
you have to unblock the hero explicitely by calling
<tt>sol.map.hero_unfreeze()</tt>.

- <tt>event_shop_item_buying(shop_item_name)</tt>:
Called when the player wants to buy an item in a shop
and has enough money: if you return false, the player cannot buy it.

- <tt>event_shop_item_bought(shop_item_name)</tt>:
called when the player has just bought an item in a shop

- <tt>event_door_open(door_name)</tt>:
called when a door has just been open

- <tt>event_door_closed(door_name)</tt>:
called when a door has just been closed

- <tt>event_block_moved(block_name)</tt>:
called when a block has just been pushed or pulled
by the hero on a section of 16 pixels (or less if there was an obstacle)

- <tt>event_enemy_dying(enemy_name)</tt>:
Called when an enemy of this map is dying (its kill animation starts).

- <tt>event_enemy_dead(enemy_name)</tt>:
Called when an enemy of this map is dead (and its kill animation is finished).

@subsection events_item Item scripts

- <tt>event_update()</tt>:
called at each cycle (so take care of the performances)

- <tt>event_set_suspended(suspended)</tt>:
called when the game is suspended or resumed

- <tt>event_map_changed(new_map_id)</tt>:
called when a map becomes the current map

- <tt>event_dialog_started(dialog_id)</tt>:
(triggered only if this item script started the dialog):
called when a dialog box starts

- <tt>event_dialog_finished(dialog_id, answer)</tt>:
(triggered only if this item script started the dialog):
called when a dialog finishes (i.e. once its last group of 3 lines
is finished)

- <tt>event_npc_interaction(npc_name)</tt>:
(triggered only if the npc has the property to notify the item controlled by this script):
called when the hero interacts with an NPC by pressing the action key

- <tt>event_npc_interaction_finished(npc_name)</tt>:
(triggered only if the NPC has the property to notify the item controlled by this script):
called when the hero has just interacted with an NPC by pressing the action key

- <tt>event_npc_interaction_item(npc_name, item_name, variant)</tt>:
(triggered only if the NPC has the property to notify the item controlled by this script):
called when the hero interacts with an NPC by using ANY inventory item;
returns true if an interaction actually happened

- <tt>event_npc_interaction_item_finished(npc_name, item_name, variant)</tt>:
(triggered only if the NPC has the property to notify the item controlled by this script):
called when the hero has just interacted with an NPC by using ANY inventory item

- <tt>event_npc_collision_fire(npc_name)</tt>:
(triggered only if the NPC has the property to notify the item controlled by this script):
called when some fire touches an NPC

- <tt>event_appear(variant, savegame_variable, falling_height)</tt>:
Called when a pickable item whose type is controlled by this script has
just appeared on the map.

- <tt>event_movement_changed()</tt>:
called when something changes in the movement of a pickable item whose type is controlled by this script

- <tt>event_obtaining(variant, savegame_variable)</tt>:
called when the player is obtaining a treasure corresponding to the item controlled by this script

- <tt>event_obtained(variant, savegame_variable)</tt>:
called when the player has finished brandishing a treasure corresponding to the item controlled by this script

- <tt>event_variant_changed(variant)</tt>:
called when the saved possession state of the item controlled by this script has just changed

- <tt>event_amount_changed(amount)</tt>:
called when the amount of the item controlled by this script has just changed

- <tt>event_use()</tt>:
called when the hero starts using the item controlled by this script from his inventory

@subsection events_enemy Enemy scripts

- <tt>event_update()</tt>:
called at each cycle (so take care of the performances)

- <tt>event_set_suspended(suspended)</tt>:
called when the game is suspended or resumed

- <tt>event_dialog_started(dialog_id)</tt>:
(triggered only if this enemy script started the dialog):
called when a dialog starts

- <tt>event_dialog_finished(dialog_id, answer)</tt>:
(triggered only if this enemy script started the dialog):
called when a dialog finishes (i.e. once its last group of 3 lines is finished)

- <tt>event_appear()</tt>:
called when an instance of the enemy controlled by this script has just been created on the map

- <tt>event_enabled()</tt>:
called when the enemy has just been enabled

- <tt>event_disabled()</tt>:
called when the enemy has just been disabled

- <tt>event_restart()</tt>:
Called when the enemy is restarting its movement because
something happended (for example the enemy has just been created,
or it was just hurt).
If your enemy moves, it is usual to create its movement in this function.

- <tt>event_pre_display()</tt>:
called just before the enemy is displayed (you may display additional things below the enemy)

- <tt>event_post_display()</tt>:
called just after the enemy is displayed (you may display additional things above the enemy)

- <tt>event_position_changed(x, y)</tt>:
called when the enemy has moved

- <tt>event_layer_changed(layer)</tt>:
called when the layer of the enemy has changed

- <tt>event_obstacle_reached()</tt>:
called when the movement of the enemy was stopped because of an obstacle.

- <tt>event_movement_changed(movement)</tt>:
called when something changes in the movement of the enemy

- <tt>event_movement_finished(movement)</tt>:
called when the movement of the enemy is finished

- <tt>event_sprite_frame_changed(sprite, animation, frame)</tt>:
called when the current frame of a sprite of the enemy has changed

- <tt>event_sprite_animation_finished(sprite, animation)</tt>:
called when the animation of a sprite of the enemy has just finished

- <tt>event_collision_enemy(other_name, other_sprite, my_sprite)</tt>:
called when the enemy detects a collision with another enemy

- <tt>event_custom_attack_received(attack, sprite)</tt>:
Called when the enemy receives an attack with a custom effect.
<tt>attack</tt> can be "sword", "thrown_item", "explosion",
"arrow", "hookshot", "boomerang", or "fire".
You have to define what happens, for example hurting the enemy, making a
special reaction, etc. If the attacks comes from a pixel-precise collision
test, the sprite that receives the attack is passed as a parameter.

- <tt>event_hurt(attack, life_lost)</tt>:
Called when the enemy is hurt.
<tt>attack</tt> can be "sword", "thrown_item", "explosion",
"arrow", "hookshot", "boomerang", or "fire".
This function is called after removing <tt>life_lost</tt> life points.

- <tt>event_dead()</tt>:
called when the enemy is killed and has finished to die

- <tt>event_immobilized()</tt>:
called when the enemy is immobilized

- <tt>event_message_received(src_enemy, message)</tt>:
Called when the enemy receives a string message from another enemy.

@subsection events_menu Menu scripts

- <tt>event_menu_started</tt>:
Called when the menu has just started.

- <tt>event_display(dst_surface)</tt>:
Called when redrawing the screen. You have to display your menu on the
surface <tt>dst_surface</tt>.

- <tt>event_key_pressed(key, modifiers)</tt>:
Called when the user has just pressed any keyboard key (directional or not)
  - <tt>key</tt> (string): name of the key pressed
  - <tt>modifiers</tt> (table): a table whose keys may contain "shift",
    "control" and "alt" (indicates what modifier keys were pressed during the
    input event)

- <tt>event_key_released(key)</tt>:
Called when the user has just released any keyboard key (directional or not)
  - <tt>key</tt> (string): name of the key released

- <tt>event_joypad_button_pressed(button)</tt>:
Called when the user has just pressed a joypad button.
  - <tt>button</tt> (number): number of the button that was pressed

- <tt>event_joypad_button_released(button)</tt>:
Called when the user has just released a joypad button.
  - <tt>button</tt> (number): number of the button that was released

- <tt>event_joypad_axis_moved(axis, state)</tt>:
Called when the user has just moved a joypad axis.
  - <tt>axis</tt> (number): number of the axis that was moved
  - <tt>state</tt> (number): the new state of the axis: -1 (left or up),
    0 (centered) or 1 (right or down)

- <tt>event_joypad_hat_moved(hat, direction8)</tt>:
Called when the user has just moved a joypad hat.
  - <tt>hat</tt> (number): number of the hat that was moved
  - <tt>state</tt> (number): the new direction of the hat: -1 if the hat is
    centered, and 0 to 7 if the hat is is one of the eight main directions

- <tt>event_direction_pressed(direction8)</tt>:
Called when the user has just pressed a directional keyboard key
or changed a direction on the joypad.
This function is redundant with <tt>event_keyboard_key_pressed()</tt>,
<tt>event_joypad_axis_moved</tt> and <tt>event_joypad_hat_moved()</tt>.
Its only purpose is to provide more easily information about directional
inputs.
  - <tt>direction8</tt> (number): the direction that was pressed, in an 8-direction
    system (0 to 7)

*/

