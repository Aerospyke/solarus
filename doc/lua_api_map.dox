/**
\page lua_api_map Map

\tableofcontents

Maps are areas where the \ref lua_api_game "game" takes place.
They may be rooms, houses, entire dungeon floors, parts of the outside
world or any place.
The active map contains many objects called
\ref lua_api_entity "map entities" (or just "entities" to be short).
%Map entities include everything that has a position on the map:
the \ref lua_api_hero "hero",
the \ref lua_api_tile "tiles",
the \ref lua_api_enemy "enemies",
the \ref lua_api_pickable "pickable treasures", etc.
See the \ref lua_api_entity "entity API" for more details.

\section lua_api_map_overview Overview

\subsection lua_api_map_overview_position Position of entities

A map has a rectangular size in pixels. The width and the height are always
multiples of 8 pixels, and most \ref lua_api_entity "map entities" usually
stay aligned on a grid of squares of 8*8 pixels (except when they are moving).

Thus, each \ref lua_api_entity "entity" has some coordinates <tt>X,Y</tt>
on the map. But its position is also defined by a third value: its layer.
The map has 3 distinct layers that are stacked: the low layer, the
intermediate layer and the high layer.
Each layer has its own set of entities.
Layers allow to implement maps with multi-level content, like a bridge
between two higher platforms. The \ref lua_api_hero "hero" 
(as well as \ref lua_api_enemy "enemies" and any other
\ref lua_api_entity "map entity") is then able to
walk either above or under the bridge, depending on his layer.
Entities like \ref lua_api_stairs "stairs" and
\ref lua_api_jumper "jumpers" can change the layer of the hero
automatically, and you can also do that from your Lua script.

\subsection lua_api_map_overview_tileset Tileset

The graphic skin of a map is called a \ref tileset_syntax "tileset". The
tileset defines the small patterns used to draw \ref lua_api_tile "tiles"
and also some other \ref lua_api_entity "entities" that may depend on the
skin.
For example, you can have a forest tileset, a castle tileset, etc.
Each map has only one tileset, but tilesets have no special size limitation.

\subsection lua_api_map_overview_files Map files

A map can contain many types of \ref lua_api_entity "entities".
%Map entities can be either declared in the
map data file or created dynamically.
Thus, a map with id \c XXXX is managed by two distinct files:
- In the data file <tt>maps/XXXX.dat</tt> are declared all entities that
  initially compose your map (most importantly: the
  \ref lua_api_tile "tiles").
  You normally don't need to edit this file by hand:
  you can use the quest editor
  (but if you want to, \ref map_syntax "here is the syntax").
- In the script file <tt>maps/XXXX.lua</tt> (which is optional),
  you define the dynamic behavior
  of your map, using the features of the map Lua type described on this page
  (and the rest of the Solarus API will also be very useful).

When the player enters a map, the engine first creates the \ref lua_api_entity
"entities"
declared in the map data file
<tt>maps/XXXX.dat</tt>, and then it runs your script
<tt>maps/XXXX.lua</tt>.
The Lua map object is passed as parameter of your script
(remember that any Lua script is implicitly a function and can have parameters).
Use the Lua notation \c "..." to get this parameter and store
it into a regular variable.

Here is a basic example of script for a map that does nothing special
except turning the lights off and showing an evil welcome dialog when the
hero enters it.
\verbatim
-- First, we put the parameter into a variable called "my_map".
-- (In Lua, the notation "..." refers to the parameter(s) of the script.)
local my_map = ...

-- Event called when the player enters the map, at initialization time.
function my_map:on_started()

  -- Put the room into the dark (before the first draw).
  self:set_light(0)
end

-- Event called when the player enters the map, after the opening transition.
function my_map:on_opening_transition_finished()

  -- Show an evil welcome dialog.
  self:start_dialog("welcome_to_darkness")
end
\endverbatim

In practice, many maps have short scripts like this or even no script at all.
Sometimes, everything that you define in the data file
(with the help of the editor) is enough.
You need a script when there is something dynamic to program on your map:
opening a \ref lua_api_door "door" when a
\ref lua_api_switch "pressure plate" is pressed,
making a \ref lua_api_chest "treasure chest" appear when some
\ref lua_api_enemy "enemies" are killed,
showing a dialog with an \ref lua_api_npc "NPC" that depends on
whether the player has accomplished a particular action before, etc. 

\subsection lua_api_map_overview_lifetime Lifetime of maps

At any moment, during the \ref lua_api_game "game",
only one map is active:
the one drawn on the game screen.
That map is also the one where the \ref lua_api_hero "hero"
is currently located.
Only the active map has its entities living in it.
Other maps are not loaded. If the player leaves the map and comes back later,
your Lua map object will be a new one the second time.
Your entities will be reloaded as specified in the
\ref map_syntax "map data file" and your map script will be executed again.

If you want some data or behavior to persist when the player comes back,
like the position of an \ref lua_api_npc "NPC" or whether a puzzle was solved,
you can store the information into the \ref lua_api_game_set_value "savegame".
Alternatively, if you don't want these data to be saved, but you want to
remember then during the current \ref lua_api_game "game" session,
you can store the information as a field the
\ref lua_api_game "game" object. The game object persists until the player
stops playing and comes back to the title screen or restarts the game.

\remark Some entities save their state automatically if you want, like
whether a \ref lua_api_chest "treasure chest" is open, whether a
\ref lua_api_door "door" is open or whether an \ref lua_api_enemy "enemy"
is killed. Therefore, you have nothing to do for such entities: they keep
their state.

\subsection lua_api_map_overview_table Accessing maps like tables

Like other essential Solarus types (including \ref lua_api_game "game",
\ref lua_api_item "items" and
\ref lua_api_entity "map entities"),
a fundamental property of maps is that even if they
are userdata, they can also be used like Lua tables.

This property is actually what allows you to define callbacks on your map.
But you can store any data in your map object,
including new functions specific to your particular map.
Here is an example that uses this feature:
\verbatim
-- Example of a map with 3 switches to activate in the correct order.
-- We assume that 3 switches exist with names "switch_1", "switch_2" and "switch_3".
local map = ...

function map:on_started()
  map.next_switch_index = 1
  -- Equivalent to: map["next_switch_index"] = 1
end

-- Called when the player walks on the switch named "switch_1".
function switch_1:on_activated()
  -- Check that switch_1 is the correct switch to activate.
  map:check_switch(self)
end

function switch_2:on_activated()
  map:check_switch(self)
end

function switch_3:on_activated()
  map:check_switch(self)
end

function map:check_switch(switch)
  if switch:get_name() == "switch_" .. map.next_switch_index then
    -- Okay so far.
    map.next_switch_index = map.next_switch_index + 1
    if map.next_switch_index > 3 then
      -- Finished!
      sol.audio.play_sound("secret")
      map:start_dialog("congratulations")
    end
  else
    -- Wrong switch: reset the puzzle.
    sol.audio.play_sound("wrong")
    switch_1:set_activated(false)
    switch_2:set_activated(false)
    switch_3:set_activated(false)
    map.next_switch_index = 1
  end
end
\endverbatim
In this example, you see that we add three values to the map object, like it
was a table:
\c next_switch_index (a number),
\c on_started (a function) and
\c check_switch (a function).
Actually, we also use this feature on the three switches:
we add a value \c on_activated on them.

\remark You may wonder how we can access \c switch_1, \c switch_2
and \c switch_3 without declaring them. There is a mechanism that makes all
named \ref lua_api_entity "entities" directly accessible in the environment
of the map script. See \ref lua_api_map_get_entity "map:get_entity()"
for more details.

But the example has some issues.
The three \ref lua_api_switch "switches" are managed by duplicated code.
This is error-prone because and one day, we will probably want to make a similar
puzzle with 50 entities instead of just 3.
To make your map easier to maintain, the following and equivalent version is
much preferred:
\verbatim
local map = ...

-- Get the number of entities starting with "switch_".
map.nb_switches = map:get_entities_count("switch_")

function map:on_started()
  map.next_switch_index = 1
end

function switch_1:on_activated()
  map:check_switch(self)
end

for i = 2, map.nb_switches do
  -- Define the same on_activated() method as switch_1
  map_get_entity("switch_" .. i).on_activated = switch_1.on_activated
end

function map:check_switch(switch)
  if switch:get_name() == "switch_" .. map.next_switch_index then
    -- Okay so far.
    map.next_switch_index = map.next_switch_index + 1
    if map.next_switch_index > map.nb_switches then
      -- Finished!
      sol.audio.play_sound("secret")
      map:start_dialog("congratulations")
    end
  else
    -- Wrong switch: reset the puzzle.
    sol.audio.play_sound("wrong")
    for i = 1, map.nb_switches do
      map:get_entity("switch_" .. i):set_activated(false)
    end
    map.next_switch_index = 1
  end
end
\endverbatim

This improved version is more evolutive: it does not even hardcode the number
of \ref lua_api_switch "switches" in the puzzle.
Thus, if you add switch called \c "switch_4" from the editor,
the script will be directly take it into account in the puzzle.

\section lua_api_map_methods Methods of the type map

\subsection lua_api_map_get_id map:get_id()

Returns the id of this map.
- Return value (string): Id of the map.

\remark This id appears in the name of \ref
  lua_api_map_overview_files "map files".

\subsection lua_api_map_get_game map:get_game()

Returns the current game.
- Return value (\ref lua_api_game "game"): The game that is currently running
  the map.

\subsection lua_api_map_get_world map:get_world()

Returns the world name that was set on this map.

The world name is a property defined in the
\ref lua_api_map_overview_files "map data file".
Worlds allow to group maps together.
The world can be any arbitrary name. Maps that have the same world name
are considered to be part of the same environment.
For example, your map can be in a world named \c "outside_world",
\c "dungeon_1" or \c "some_scary_cave".

The world property is used to decide when to set the starting location of
the player (the place where he starts when loading his
\ref lua_api_game "savegame").
The starting location is automatically set by the engine
when the world changes (not when the map changes).

Some other features may also rely on the world property, like the state of
\ref lua_api_crystal_switch "crystal switches". Their state persists
between all maps of the current world and is reset when the world changes.
- Return value (string): Name of the world of the current map.

\subsection lua_api_map_get_floor map:get_floor()

Returns the floor of the current map if any.

The floor is an optional property defined in the
\ref lua_api_map_overview_files "map data file".

The engine does not do anything particular with this floor property.
But you can use it in scripts,
for example to show the current floor on the HUD
when it changes or to make a minimap \ref lua_api_menu "menu".
- Return value (number): The current floor. \c 0 is the first floor, \c 1
  is the second floor, \c -1 is the first basement floor, etc.
  \c nil means that this map is not part of a floor system.

\subsection lua_api_map_get_size map:get_size()

Returns the size of this map in pixels.
- Return value 1 (number): The width in pixels (always a multiple of 8).
- Return value 2 (number): The height in pixels (always a multiple of 8).

\subsection lua_api_map_get_location map:get_location()

Returns the x,y location of this map in its
\ref lua_api_map_get_world "world".

The engine uses this information to implement scrolling between two adjacent
maps.

For example, you can also use this property in scripts if you want to show
the position
of the hero on the minimap \ref lua_api_menu "menu" of your outside
\ref lua_api_map_get_world "world".
Indeed, your outside world is probably not a single map, but it is usually
composed of several adjacent maps.
- Return value 1 (number): X position of the top-left corner of this map
  relative to its world.
- Return value 2 (number): Y position of the top-left corner of this map
  relative to its world.

\subsection lua_api_map_get_tileset map:get_tileset()

Returns the name of the \ref lua_api_map_overview_tileset "tileset"
of the current map.
- Return value (string): Id of the current tileset.

\subsection lua_api_map_set_tileset map:set_tileset(tileset_id)

Changes the \ref lua_api_map_overview_tileset "tileset"
of the current map.

It is your responsability to make sure that
the new tileset is be compatible with the previous one:
every tile of the previous tileset must exist in the new one
and have the exact same properties, and only the images can differ.
Internally, this function actually keeps the data of the previous tileset
and only loads the image of the new tileset.
- \c tileset_id (string): Id of the new tileset to set.

\remark If the new tileset is not compatible with the previous one,
  tiles will be displayed with wrong graphics.

\subsection lua_api_map_set_tileset map:is_dialog_enabled()

Returns whether the dialog box is currently active.
- Return value (boolean): \c true if a dialog is being shown.

\subsection lua_api_map_start_dialog map:start_dialog(dialog_id)

Shows a dialog box.

The dialog box must not be already active.
- \c dialog_id (string): Id of the dialog to show.
  The corresponding dialog must exist in the \c dialogs.dat
  file of the current \ref lua_api_language "language".

\subsection lua_api_map_set_dialog_variable map:set_dialog_variable(dialog_id, value):

Sets a value to display inside a dialog.

This function must be used if part of the text is only
known at runtime: for example if you want to display in a dialog
the name of the player or some number computed by your script.

In the specified dialog, the special sequence \c $v will
be substituded by this value.
This function should be called before starting the dialog.
If the same dialog is displayed several times,
calling this function only once is sufficient.
- \c dialog_id (string): Id of the dialog where this value should be
  substituted.

\remark For now, you cannot make a dialog with multiple variables.
  You will have to make several dialogs instead.

\subsection lua_api_map_set_dialog_style map:set_dialog_style(style)

Sets the style of the dialog box for subsequent dialogs.
- \c style (number): \c 0 for a usual dialog box,
  1 for no dialog box (only the text is displayed).

\remark This function will be removed in a future version because the
  dialog box will become scriptable (you will have full control of how to
  draw your dialog box).

\subsection lua_api_map_set_dialog_position map:set_dialog_position(position)

Sets the vertical position of the dialog box.
- \c position (number): \c 0 for automatic (let the engine choose so that
  the dialog box does not hide the player), \c 1 for the top of the screen,
  \2 for the bottom of the screen.

\remark This function will be removed in a future version because the
  dialog box will become scriptable (you will have full control of how to
  draw your dialog box).

\subsection lua_api_map_draw_dialog_box map:draw_dialog_box()

Draws the dialog box on the screen.

When a dialog is active, call this function at an appropriate moment
(for example, after your pause menu but before your HUD).

\remark This function will be removed in a future version because the
  dialog box will become scriptable (you will have full control of drawing
  your dialog box).

\subsection lua_api_map_set_pause_enabled map:set_pause_enabled(pause_enabled)

Sets whether the player can pause the \ref lua_api_game "game".
- \c pause_enabled (boolean): \c true to allow the player to pause the
  game.

\remark This function applies to the built-in \ref
  lua_api_game_features_command "pause command".
  Your script can still pause the game explicitly by calling
  \ref lua_api_game_set_paused "game:set_paused()".

\subsection lua_api_map_get_light map:get_light()

Returns the current light level of the map.
- Return value (number): The light level (\c 0: no light except near the
  \ref lua_api_hero "hero", \c 1: full light).

\subsection lua_api_map_set_light map:set_light(light)

Sets the light level of the map.
- \c light (number): The light level to set (\c 0: no light except near the
  \ref lua_api_hero "hero", \c 1: full light).

\subsection lua_api_map_move_camera map:move_camera(x, y, speed, callback, [delay_before], [delay_after])

Initiates a camera moving sequence.

Normally, the camera is always centered on the \ref lua_api_hero "hero".
You can use this function to temporarily move the camera somewhere else,
like to a place where a \ref lua_api_chest "chest" or an
\ref lua_api_enemy "enemy" will appear.

The whole sequence happens as follows.
The camera moves towards a target point.
When the target is reached, after a first delay,
your callback function is called.
Then, after a second delay, the camera moves back towards the hero.

The game is suspended during the whole sequence (meaning that
the hero and other \ref lua_api_entity "map entities" cannot move).
- x (number): X coordinate of the target, relative to the map's top-left corner.
- y (number): Y coordinate of the target, relative to the map's top-left corner.
- speed (number): Speed of the camera movement in pixels per second
  (a recommended value is \c 250).
- callback (function): A function to be called when the camera reaches the
  target (after \c delay_before).
- delay_before (number, optional): A delay in milliseconds before calling
  your function once the target is reached (default \c 1000).
- delay_after (number, optional): A delay in milliseconds after calling
  your function, before the camera goes back (default \c 1000).

Example of use:
\verbatim
-- Show a chest when the hero activates a switch.
function my_switch:on_activated()
  local x, y = my_chest:get_position()
  map:move_camera(x, y, 250, function()
    sol.audio.play_sound("chest_appears")
    my_chest:set_enabled(true)
  end)
end
\endverbatim

\remark Note that this method is asynchronous.
  Like \ref lua_api_timer "timers", this function it returns immediately.
  Your callback will be automatically called later by the engine.

\subsection lua_api_map_draw_sprite map:draw_sprite(sprite, x, y)

Draws a \ref lua_api_sprite "sprite" at the given map coordinates.

This function can be used as an alternative to
\ref lua_api_drawable_draw "sprite:draw()" in order to draw the sprite
relative to the map (instead of relative to the screen).

More precisely, the origin point of the sprite will be displayed at this
location, relative to the the top-left corner of the map.

Normally, \ref lua_api_entity "map entities" automatically draw their
sprites, so you don't have to call this function.
However, you may need this function if you did not associate your sprite
to the entity for some reason (see in particular
\ref lua_api_enemy_create_sprite "enemy:create_sprite"),
or if you want to draw something relative to map coordinates but
without using a map entity.

\subsection lua_api_map_get_crystal_state map:get_crystal_state()

Returns the configuration of \ref lua_api_crystal_block
"crystal switches".
- Return value (boolean): \c false initially (orange blocks lowered),
  \c true otherwise (blue blocks lowered).

\subsection lua_api_map_set_crystal_state map:set_crystal_state(state)

Sets the configuration of \ref lua_api_crystal_block
"crystal switches".

This state persists accross maps of the same \ref lua_api_map_get_world
"world", and is reset when the world changes and when the
\ref lua_api_game "savegame" is reloaded.
- \c inverted (boolean): \c false to set the initial configuration
  (orange blocks lowered), \c true to the modified one (blue blocks lowered).

\subsection lua_api_map_change_crystal_state map:change_crystal_state()

Inverts the configuration of \ref lua_api_crystal_block
"crystal switches".

\remark Equivalent to
<tt>map:set_crystal_state(not map:get_crystal_state())</tt>.

\subsection lua_api_map_open_doors map:open_doors(prefix)

Opens the \ref lua_api_door "doors"
whose name starts with the specified prefix,
enables or disables relative
\ref lua_api_dynamic_tile "dynamic tiles" accordingly
and plays the \c "door_open" \ref lua_api_audio_play_sound
"sound".

Opening a door may be more complex than just modifying
a single \ref lua_api_door "door entity".
Indeed, there is often a corresponding door is the adjacent
room that you also want to open (that corresponding
door is another \ref lua_api_entity "entity").
Name both doors with the same prefix, and you can use this function to
open both of them.

Furthermore, you sometimes want \ref
lua_api_dynamic_tile "dynamic tiles"
to be shown or hidden depending on the state of a door.
When a door is open,
all dynamic tiles whose prefix is the door's name
followed by <tt>_open</tt> or <tt>_closed</tt> are automatically
enabled or disabled, respectively.
- \c prefix (string): Prefix of the name of doors to open.

\remark The doors will be really closed once the opening animation of
  their sprite is finished. However, they immediately become obstalces.

\subsection lua_api_map_close_doors map:close_doors(prefix)

Closes the \ref lua_api_door "doors"
whose name starts with the specified prefix,
enables or disables relative
\ref lua_api_dynamic_tile "dynamic tiles" accordingly
and plays the \c "door_closed" \ref lua_api_audio_play_sound
"sound".

Closing a door may be more complex than just modifying
a single \ref lua_api_door "door entity".
Indeed, there is often a corresponding door is the adjacent
room that you also want to open (that corresponding
door is another \ref lua_api_entity "entity").
Name both doors with the same prefix, and you can use this function to
close both of them.

Furthermore, you sometimes want \ref
lua_api_dynamic_tile "dynamic tiles"
to be shown or hidden depending on the state of a door.
When a door is closed,
all dynamic tiles whose prefix is the door's name
followed by <tt>_open</tt> or <tt>_closed</tt> are automatically
disabled or enabled, respectively.
- \c prefix (string): Prefix of the name of doors to close.

\subsection lua_api_map_set_doors_open map:set_doors_open(prefix, [open])

Like \ref lua_api_map_open_doors "map:open_doors()" or
\ref lua_api_map_close_doors "map:close_doors()",
but does not play any sound or any sprite animation.

This function is intended to be called when you don't want the player
to notice the change, typically when your map starts
(i.e. from the \ref lua_api_map_on_started map:on_started() event).
- \c prefix (string): Prefix of the name of doors to set.
- \c open (boolean, optional): \c true to open the doors, \c false
  to close them (no value means \c true).

\subsection lua_api_map_get_entity map:get_entity(name)

Returns the \ref lua_api_entity "map entity" with the specified name
if it exists on this map. 
Entity names are unique (two entities cannot exist on the map
with the same name at the same time).

As a convenient feature, map entities can also be accessed directly
through the environment of the \ref lua_api_map_overview_files "map script".
In other words, you can just write <tt>bob:get_position()</tt> as an
equivalent to <tt>map:get_entity("bob"):get_position()</tt>.
- \c name (string): Name of the map entity to get.
- Return value (\ref lua_api_entity "entity"): The corresponding entity,
  or \c nil if there exists no entity with this name on the map.

\remark Technical note for curious Lua experts:
  the mechanism that makes map entities
  directly accessible in the map script environment is lazy
  (it is implemented as an \c __index metamethod). Entities are imported
  to the Lua side only when your script requests them.
  If you have thousands of named entities in your map, you won't have
  thousands of useless objects living in Lua.
  Only the ones your script tries to access are imported.

\subsection lua_api_map_has_entity map:has_entity(name)

Returns whether there currently exists a
\ref lua_api_entity "map entity" with the specified name on the map.
- \c name (string): Name of the \ref lua_api_entity "map entity" to check.
- Return value (boolean): \c true if such an entity exists.

\remark Equivalent to <tt>map:get_entity(name) ~= nil</tt> (but a bit
  lighter because it avoids to export the entity to Lua).

\subsection lua_api_map_get_entities map:get_entities(prefix)

Returns all \ref lua_api_entity "map entities"
whose name has the specified prefix.
- \c prefix (string): Prefix of the entities to get.
- Return value (table): An array of all existing entities with this prefix.

\subsection lua_api_map_get_entities_count map:get_entities_count(prefix)

Returns the number of \ref lua_api_entity "map entities"
having the specified prefix.
- \c prefix (string): Prefix of the entities to count.
- Return value (number): The number of entities having this prefix on the map.

\remark Equivalent to <tt>#map:get_entities(prefix)</tt> (but avoids the
  table creation and the export of entities to Lua).

\subsection lua_api_map_has_entities map:has_entities(prefix)

Returns whether there exists at least one \ref lua_api_entity
"map entity" having the specified prefix.

This function can be used for example to checker whether a group of
\ref lua_api_enemy "enemies" is dead.
- \c prefix (string): Prefix of the entities to check.
- Return value (boolean): \c true if at least one entity with this prefix
  exists on the map.

\remark Equivalent to <tt>map:get_entities_count(prefix) > 0</tt> but faster
  when there are a lot of entities
  (because it stops searching as soon as there is a match).

\subsection lua_api_map_set_entities_enabled map:set_entities_enabled(prefix, [enabled])

Enables or disables all \ref lua_api_entity "map entities" having
the specified prefix.

Disabled entities are not displayed and are not updated.
Therefore, they don't move and their collisions are no longer detected.
But they still exist and can be enabled back later.
- \c prefix (string): Prefix of the entities to change.
- \c enable (boolean): \c true to enable them, \c false to disable them
  (no value means \c true).

\remark Equivalent to calling \ref lua_api_entity_set_enabled
  "entity:set_enabled()" on a group of entities.

\subsection lua_api_map_remove_entities map:remove_entities(prefix)

Removes and destroys all \ref lua_api_entity "map entities"
having the specified prefix.

Once an entity is removed, it is destroyed and it no longer exists on the map.
A good practice is to avoid keeping references to destroyed entities in your
scripts so that they can be garbage-collected by Lua.
- \c prefix (string): Prefix of the entities to remove from the map.

\remark Equivalent to calling \ref lua_api_entity_remove
  "entity:remove()" on a group of entities.

\subsection lua_api_map_create_destination map:create_destination(properties)

Creates an entity of type
\ref lua_api_destination "destination"
on the map.
- \c properties (table): A table that describles all properties of the entity
  to create. Its key-value pairs must be:
  - \c name (string): Name identifying the entity.
  - \c layer (number): Layer on the map (\c 0: low, \c 1: intermediate,
    \c 2: high).
  - \c x (number): X coordinate on the map.
  - \c y (number): Y coordinate on the map.
  - \c direction (number): Direction that the hero takes when arriving on
    the destination, between \c 0 (East) and \c 3 (South) or \c -1 to keep
    his direction unchanged).
  - \c sprite_name (string, optional): Name of the animation set of a
    \ref lua_api_sprite "sprite" to create for the destination.
    No value means no sprite (the destination will then be invisible).
- Return value (\ref lua_api_destination "destination"): The destination
  created.

\subsection lua_api_map_create_teletransporter map:create_teletransporter(properties)

Creates an entity of type
\ref lua_api_teletransporter "teletransporter"
on the map.
- \c properties (table): A table that describles all properties of the entity
  to create. Its key-value pairs must be:
  - \c name (string): Name identifying the entity.
  - \c layer (number): Layer on the map (\c 0: low, \c 1: intermediate,
    \c 2: high).
  - \c x (number): X coordinate on the map.
  - \c y (number): Y coordinate on the map.
  - \c width (number): Width of the entity in pixels.
  - \c height (number): Height of the entity in pixels.
  - \c sprite_name (string, optional): Name of the animation set of a
    \ref lua_api_sprite "sprite" to create for the teletransporter.
    No value means no sprite (the teletransporter will then be invisible).
  - \c sound_id (string, optional): Sound to \ref lua_api_audio_play_sound
    "play" when the \ref lua_api_hero "hero" uses the
    teletransporter. No value means no sound.
  - \c transition_style (number): Style of transition to play when the hero
    uses the teletransporter. \c 0: immediate (no transition), \c 1:
    fade-out effect, \c 2: scrolling between maps.
  - \c destination_map_id (string): Id of the map to transport to (can be
    the current map).
  - \c destination_name (string): Location on the destination map.
    Can be the name of a \ref lua_api_destination "destination" entity,
    the special value \c "_same" to keep the hero's coordinates,
    or the special value \c "_side" to place on hero on the corresponding side
    of an adjacent map (normally used with the scrolling transition style).
- Return value (\ref lua_api_teletransporter "teletransporter"): The
  teletransporter created.

\subsection lua_api_map_create_pickable map:create_pickable(properties)

Creates an entity of type
\ref lua_api_pickable "pickable treasure"
on the map.
- \c properties (table): A table that describles all properties of the entity
  to create. Its key-value pairs must be:
  - \c layer (number): Layer on the map (\c 0: low, \c 1: intermediate,
    \c 2: high).
  - \c x (number): X coordinate on the map.
  - \c y (number): Y coordinate on the map.
  - \c treasure_name (string, optional): Kind of treasure to create
    (the name of an \ref lua_api_item "equipment item").
    If this value is not set, or corresponds to a
    \ref lua_api_item_is_obtainable "non obtainable" item, then
    no entity is created and \c nil is returned.
  - \c treasure_variant (number, optional): Variant of the treasure
    (because some \ref lua_api_item "equipment items"
    may have several variants).
    The default value is \c 1 (the first variant).
  - \c treasure_savegame_variable (string, optional): Name of the boolean
    value that stores in the \ref lua_api_game "savegame"
    whether this pickable treasure was found.
    No value means that the treasure is not saved.
    If the treasure is saved and the player already has it, then no entity
    is be created and \c nil is returned.
- Return value (\ref lua_api_pickable "pickable treasure"): The pickable
  treasure created, or \c nil if the item is not set, not
  \ref lua_api_item_is_obtainable "obtainable", or if the pickable treasure is
  already found (for a saved one).

\remark The state of the pickable treasure (obtained or not)
  and the possessed variant of the \ref lua_api_item "item"
  (a number)
  are two independent values that have different meanings
  and are saved separately.

\subsection lua_api_map_create_destructible map:create_destructible(properties)

Creates an entity of type
\ref lua_api_destructible "destructible object"
on the map.
- \c properties (table): A table that describes all properties of the entity
  to create. Its key-value pairs must be:
  - \c layer (number): Layer on the map (\c 0: low, \c 1: intermediate,
    \c 2: high).
  - \c x (number): X coordinate on the map.
  - \c y (number): Y coordinate on the map.
  - \c subtype_name (string): The kind of destructible object to create:
    \c "pot", \c "bush", \c "stone_small_white", \c "stone_small_black",
    \c "grass" or \c "bomb_flower".
  - \c treasure_name (string, optional): Kind of
    \ref lua_api_pickable "pickable treasure" to hide in the
    destructible object
    (the name of an \ref lua_api_item "equipment item").
    If this value is not set, or corresponds to a
    \ref lua_api_item_is_obtainable "non obtainable" item, then
    no treasure is placed in the destructible object.
  - \c treasure_variant (number, optional): Variant of the treasure if any
    (because some \ref lua_api_item "equipment items"
    may have several variants).
    The default value is \c 1 (the first variant).
  - \c treasure_savegame_variable (string, optional): Name of the boolean
    value that stores in the \ref lua_api_game "savegame"
    whether the \ref lua_api_pickable "pickable treasure"
    hidden in the destructible object was found.
    No value means that the treasure (if any) is not saved.
    If the treasure is saved and the player already has it, then no
    treasure is put in the destructible object.
  - \c on_destroyed (function, optional): A function to be called when the
    \ref lua_api_hero "hero" lifts the destructible object.
- Return value (\ref lua_api_destructible "destructible object"): The
  destructible object created.

\remark The state of the treasure placed in the destructible
  object (obtained or not)
  and the possessed variant of the \ref lua_api_item "item"
  (a number)
  are two independent values that have different meanings
  and are saved separately.

\subsection lua_api_map_create_chest map:create_chest(properties)

Creates an entity of type
\ref lua_api_chest "treasure chest"
on the map.
- \c properties (table): A table that describes all properties of the entity
  to create. Its key-value pairs must be:
  - \c name (string): Name identifying the entity.
  - \c layer (number): Layer on the map (\c 0: low, \c 1: intermediate,
    \c 2: high).
  - \c x (number): X coordinate on the map.
  - \c y (number): Y coordinate on the map.
  - \c big_chest (boolean): \c true to create a big chest, \c false for a
    normal chest.
  - \c treasure_name (string, optional): Kind of treasure to place in the chest
    (the name of an \ref lua_api_item "equipment item").
    If this value is not set, or corresponds to a
    \ref lua_api_item_is_obtainable "non obtainable" item, then
    the chest will be empty.
  - \c treasure_variant (number, optional): Variant of the treasure
    (because some \ref lua_api_item "equipment items"
    may have several variants).
    The default value is \c 1 (the first variant).
  - \c treasure_savegame_variable (string, optional): Name of the boolean
    value that stores in the \ref lua_api_game "savegame"
    whether this chest is open.
    No value means that the state of the treasure is not saved.
    If the treasure is saved and the player already has it, then no
    treasure is placed in the chest (the chest will appear empty).
- Return value (\ref lua_api_chest "chest"): The treasure chest created.

\remark The state of the treasure chest (obtained or not)
  and the possessed variant of its \ref lua_api_item "item"
  \ref lua_api_chest "chest" (a number)
  are two independent values that have different meanings
  and are saved separately.

\subsection lua_api_map_create_jumper map:create_jumper(properties)

Creates an entity of type
\ref lua_api_jumper "jumper"
on the map.
- \c properties (table): A table that describes all properties of the entity
  to create. Its key-value pairs must be:
  - \c name (string): Name identifying the entity.
  - \c layer (number): Layer on the map (\c 0: low, \c 1: intermediate,
    \c 2: high).
  - \c x (number): X coordinate on the map.
  - \c y (number): Y coordinate on the map.
  - \c width (number): Width of the entity in pixels.
  - \c height (number): Height of the entity in pixels.
  - \c direction (number): Direction of the jump, between \c 0 (East)
    and \c 7 (South-East).
    If the direction is horizontal, the width must be \c 8 pixels.
    If the direction is vertical, the height must be \c 8 pixels.
    If the direction is diagonal, the size must be square. 
  - \c jump_length (number): Length of the baseline of the jump in pixels
    (see the \ref lua_api_jump_movement "jump movement" page for details).
- Return value (\ref lua_api_jumper "jumper"): The jumper created.

\subsection lua_api_map_create_enemy map:create_enemy(properties)

Creates an entity of type
\ref lua_api_enemy "enemy"
on the map.
- \c properties (table): A table that describes all properties of the entity
  to create. Its key-value pairs must be:
  - \c name (string): Name identifying the entity.
  - \c layer (number): Layer on the map (\c 0: low, \c 1: intermediate,
    \c 2: high).
  - \c x (number): X coordinate on the map.
  - \c y (number): Y coordinate on the map.
  - \c direction (number): Initial direction of the enemy, between
    \c 0 (East) and \c 3 (South).
  - \c breed (string): Kind of enemy to create.
  - \c rank (number): \c 0 for a normal enemy, \c 1 for a miniboss,
    \c 2 for a boss.
  - \c savegame_variable (number, optional): Name of the boolean value that
    stores in the \ref lua_api_game "savegame" whether this enemy is dead.
    No value means that the enemy is not saved.
    If the enemy is saved and was already killed, then no enemy is created.
    Instead, its \ref lua_api_pickable "pickable treasure" is created if it
    is a saved one.
  - \c treasure_name (string, optional): Kind of
    \ref lua_api_pickable "pickable treasure" to drop when the
    enemy is killed
    (the name of an \ref lua_api_item "equipment item").
    If this value is not set, or corresponds to a
    \ref lua_api_item_is_obtainable "non obtainable" item, then
    the enemy won't drop anything.
  - \c treasure_variant (number, optional): Variant of the treasure
    (because some \ref lua_api_item "equipment items"
    may have several variants).
    The default value is \c 1 (the first variant).
  - \c treasure_savegame_variable (string, optional): Name of the boolean
    value that stores in the \ref lua_api_game "savegame"
    whether the \ref lua_api_pickable "pickable treasure"
    of this enemy was obtained.
    No value means that the state of the treasure is not saved.
    If the treasure is saved and the player already has it, then the
    enemy won't drop anything.
- Return value (\ref lua_api_enemy "enemy" or \ref lua_api_pickable
  "pickable treasure"): The enemy created, except when it is a saved enemy
  that is already dead.
  In this case, if the enemy dropped a saved
  treasure that is not obtained yet, this
  \ref lua_api_pickable "pickable treasure" is created and returned.
  Otherwise, \c nil is returned.

\remark The state of the enemy (alive or dead),
  the state of its treasure dropped (obtained or not)
  and the possessed variant of the \ref lua_api_item "item" dropped (a number)
  are three independent values that have different meanings and
  are saved separately.

\subsection lua_api_map_create_npc map:create_npc(properties)

Creates an entity of type
\ref lua_api_npc "non-playing character" (NPC)
on the map.
- \c properties (table): A table that describes all properties of the entity
  to create. Its key-value pairs must be:
  - \c name (string): Name identifying the entity.
  - \c layer (number): Layer on the map (\c 0: low, \c 1: intermediate,
    \c 2: high).
  - \c x (number): X coordinate on the map.
  - \c y (number): Y coordinate on the map.
  - \c direction (number): Initial direction of the NPC's sprite, between
    \c 0 (East) and \c 3 (South).
  - \c subtype (number): Kind of NPC to create: \c 1 for a usual NPC who the
    player can talk to,
    \c 0 for a generalized NPC (not necessarily a person).
    See the \ref lua_api_npc "NPC documentation" for more details.
  - \c sprite_name (string, optional): Name of the animation set of a
    \ref lua_api_sprite "sprite" to create for the NPC.
    No value means no sprite (the NPC will then be invisible).
  - \c behavior (string, optional): What to do when there is an interaction
    with the NPC.
    - \c "dialog#XXXX": Starts the dialog with id \c XXXX when the player
      talks to this NPC.
    - \c "map": Forwards events to the map script
      (for example, calls the \ref lua_api_npc_on_interaction
      "on_interaction()" event of the NPC).
    - \c "item#XXXX": Forwards events to an \ref lua_api_item
      "equipment item" script
      (for example, calls the \ref lua_api_item_on_npc_interaction
      "on_interaction()" event of the equipment item with id \c XXXX).
- Return value (\ref lua_api_npc "NPC"): the NPC created.

*/

