/**
\page lua_api_map Map

Maps are areas where the \ref lua_api_game "game" takes place.
They may be rooms, houses, entire dungeon floors, parts of the outside
world or any place.
The active map contains many objects called
\ref "map entities" (or just "entities" to be short).
%Map entities include everything that has a position on the map:
the \ref lua_api_hero "hero",
the \ref lua_api_tile "tiles",
the \ref lua_api_enemy "enemies",
the \ref lua_api_pickable "pickable treasures", etc.
See the \ref lua_api_entity "entity API" for more details.

A map has a rectangular size in pixels.
Its graphic skin is called a \ref tileset_syntax "tileset". The tileset
defines the small bricks used to draw \ref lua_api_tile "tiles"
and some other \ref lua_api_entity "entities" that also depend on the skin.
For example, you can have a forest tileset, a castle tileset, etc.
Each map has only one tileset.

A map can contain many types of map entities.
Entities can be either declared in the
map data file or created dynamically.
Thus, a map named \c XXXX is managed by two distinct files:
- In the data file <tt>maps/XXXX.dat</tt> are declared all entities that
  initially compose the map (most importantly: the
  \ref lua_api_tile "tiles").
  You normally don't need to edit this file by hand:
  you can use the quest editor
  (but if you want, \ref map_syntax "here is the syntax").
- In the script file <tt>maps/XXXX.lua</tt>, you define the dynamic behavior
  of your map, using the features of the map Lua type described on this page
  (but also of the rest of the Solarus API).

When the player enters a map, the engine first creates the entities
declared in the map data file
<tt>maps/XXXX.dat</tt>, and then it runs your script
<tt>maps/XXXX.lua</tt>.
The Lua map object is passed as parameter
of your script.
Use the Lua notation \c "..." to get this parameter and store
it into a regular variable.

Here is a basic example of script for a map that does nothing special
except turning the lights off and showing an evil welcome dialog when the
hero enters it.
\verbatim
-- First, we put the parameter into a variable called "my_map".
-- (In Lua, the notation "..." refers to the parameter(s) of the script.)
local my_map = ...

-- Event called when the player enters the map, at initialization time.
function my_map:on_started()

  -- Put the room into the dark (before the first draw).
  self:set_light(0)
end

-- Event called when the player enters the map, after the opening transition.
function my_map:on_opening_transition_finished()

  -- Show an evil welcome dialog.
  self:start_dialog("welcome_to_darkness")
end
\endverbatim

In practice, many maps have short scripts like this or even no script at all.
Sometimes, everything that you define in the data file
(with the help of the editor) is enough.
You need a script when there is something dynamic to program on your map:
opening a \ref lua_api_door "door" when a
\ref lua_api_switch "pressure plate" is pressed,
making a \ref lua_api_chest "treasure chest" appear when some
\ref lua_api_enemy "enemies" are killed,
showing a dialog with an \ref lua_api_npc "NPC" that depends on
whether the player has accomplished a particular action before, etc. 

At any moment, during the \ref lua_api_game "game",
only one map is active:
the one drawn on the game screen.
That map is also the one where the \ref lua_api_hero "hero"
is currently located.
Only the active map has its entities living in it.
Other maps are not loaded. If the player leaves the map and comes back later,
your Lua map object will be a new one the second time.
Your entities will be reloaded as specified in the
\ref map_syntax "map data file" and your map script will be executed again.

TODO the game object persists accross map changes

TODO map accessed like table (example)

\section Contents

- \ref lua_api_map_methods
- \ref lua_api_map_events



- \c sol.map.dialog_start(dialog_id):
Show a dialog box.

- \c sol.map.dialog_set_variable(dialog_id, value):
Specifies a value to display inside a dialog (for example the
player's name). In this dialog, the sequence \c $v will
be substituted by this value.

- \c sol.map.dialog_set_style(style):
Sets the style of the dialog box for subsequent dialogs (0: usual dialog box,
1: no dialog box, only display the text)

- \c sol.map.hud_set_pause_enabled(bool enabled):
Allows or disallows to pause the game (and thus to save the game).

- \c sol.map.hud_set_enabled(enabled):
Hides or restores the HUD (the player can still use his items
and pause the game).

- \c sol.map.light_get():
returns the current light level of the map

- \c sol.map.light_set(light_level):
sets the light level of the map (0: no light, positive values: full light)

- \c sol.map.camera_move(x, y, speed, function, delay_before, delay_after):
moves the camera to a target point (a usual speed value is 250),
waits a delay in milliseconds (default is 1000), calls a function,
waits another delay (default is 1000) and restores the camera;
the game is suspended during the whole sequence

- \c sol.map.tileset_get():
returns the id of the tileset of this map

- \c sol.map.tileset_set(tileset_id):
Changes the tileset used to draw the map.
The new tileset must be compatible with the previous one,
i.e. every tile of the previous tileset must exist in the new one
and have the same properties.
This function keeps the tiles of the previous tileset and loads the
image of the new tileset.

- \c sol.map.sprite_display(sprite, x, y):
Displays a sprite at the given position (relative to the the map top-left
corner). The origin point of the sprite will be displayed at this location.

*/

