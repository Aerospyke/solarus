/**
\page lua_api_map Map

\tableofcontents

Maps are areas where the \ref lua_api_game "game" takes place.
They may be rooms, houses, entire dungeon floors, parts of the outside
world or any place.
The active map contains many objects called
\ref lua_api_entity "map entities" (or just "entities" to be short).
%Map entities include everything that has a position on the map:
the \ref lua_api_hero "hero",
the \ref lua_api_tile "tiles",
the \ref lua_api_enemy "enemies",
the \ref lua_api_pickable "pickable treasures", etc.
See the \ref lua_api_entity "entity API" for more details.

\section lua_api_map_overview Overview

\subsection lua_api_map_overview_position Position of entities

A map has a rectangular size in pixels. The width and the height are always
multiples of 8 pixels, and most \ref lua_api_entity "map entities" usually
stay aligned on a grid of squares of 8*8 pixels (except when they are moving).

Thus, each \ref lua_api_entity "entity" has some coordinates <tt>X,Y</tt>
on the map. But its position is also defined by a third value: its layer.
The map has 3 distinct layers that are stacked: the low layer, the
intermediate layer and the high layer.
Each layer has its own set of entities.
Layers allow to implement maps with multi-level content, like a bridge
between two higher platforms. The \ref lua_api_hero "hero" 
(as well as \ref lua_api_enemy "enemies" and any other
\ref lua_api_entity "map entity") is then able to
walk either above or under the bridge, depending on his layer.
Entities like \ref lua_api_stairs "stairs" and
\ref lua_api_jumper "jumpers" can change the layer of the hero
automatically, and you can also do that from your Lua script.

\subsection lua_api_map_overview_tileset Tileset

The graphic skin of a map is called a \ref tileset_syntax "tileset". The
tileset defines the small patterns used to draw \ref lua_api_tile "tiles"
and also some other \ref lua_api_entity "entities" that may depend on the
skin.
For example, you can have a forest tileset, a castle tileset, etc.
Each map has only one tileset, but tilesets have no special size limitation.

\subsection lua_api_map_overview_files Map files

A map can contain many types of \ref lua_api_entity "entities".
%Map entities can be either declared in the
map data file or created dynamically.
Thus, a map with id \c XXXX is managed by two distinct files:
- In the data file <tt>maps/XXXX.dat</tt> are declared all entities that
  initially compose your map (most importantly: the
  \ref lua_api_tile "tiles").
  You normally don't need to edit this file by hand:
  you can use the quest editor
  (but if you want to, \ref map_syntax "here is the syntax").
- In the script file <tt>maps/XXXX.lua</tt> (which is optional),
  you define the dynamic behavior
  of your map, using the features of the map Lua type described on this page
  (and the rest of the Solarus API will also be very useful).

When the player enters a map, the engine first creates the \ref lua_api_entity
"entities"
declared in the map data file
<tt>maps/XXXX.dat</tt>, and then it runs your script
<tt>maps/XXXX.lua</tt>.
The Lua map object is passed as parameter of your script
(remember that any Lua script is implicitly a function and can have parameters).
Use the Lua notation \c "..." to get this parameter and store
it into a regular variable.

Here is a basic example of script for a map that does nothing special
except turning the lights off and showing an evil welcome dialog when the
hero enters it.
\verbatim
-- First, we put the parameter into a variable called "my_map".
-- (In Lua, the notation "..." refers to the parameter(s) of the script.)
local my_map = ...

-- Event called when the player enters the map, at initialization time.
function my_map:on_started()

  -- Put the room into the dark (before the first draw).
  self:set_light(0)
end

-- Event called when the player enters the map, after the opening transition.
function my_map:on_opening_transition_finished()

  -- Show an evil welcome dialog.
  self:start_dialog("welcome_to_darkness")
end
\endverbatim

In practice, many maps have short scripts like this or even no script at all.
Sometimes, everything that you define in the data file
(with the help of the editor) is enough.
You need a script when there is something dynamic to program on your map:
opening a \ref lua_api_door "door" when a
\ref lua_api_switch "pressure plate" is pressed,
making a \ref lua_api_chest "treasure chest" appear when some
\ref lua_api_enemy "enemies" are killed,
showing a dialog with an \ref lua_api_npc "NPC" that depends on
whether the player has accomplished a particular action before, etc. 

\subsection lua_api_map_overview_lifetime Lifetime of maps

At any moment, during the \ref lua_api_game "game",
only one map is active:
the one drawn on the game screen.
That map is also the one where the \ref lua_api_hero "hero"
is currently located.
Only the active map has its entities living in it.
Other maps are not loaded. If the player leaves the map and comes back later,
your Lua map object will be a new one the second time.
Your entities will be reloaded as specified in the
\ref map_syntax "map data file" and your map script will be executed again.

If you want some data or behavior to persist when the player comes back,
like the position of an \ref lua_api_npc "NPC" or whether a puzzle was solved,
you can store the information into the \ref lua_api_game_set_value "savegame".
Alternatively, if you don't want these data to be saved, but you want to
remember then during the current \ref lua_api_game "game" session,
you can store the information as a field the
\ref lua_api_game "game" object. The game object persists until the player
stops playing and comes back to the title screen or restarts the game.

\remark Some entities save their state automatically if you want, like
whether a \ref lua_api_chest "treasure chest" is open, whether a
\ref lua_api_door "door" is open or whether an \ref lua_api_enemy "enemy"
is killed. Therefore, you have nothing to do for such entities: they keep
their state.

\subsection lua_api_map_overview_table Accessing maps like tables

Like other essential Solarus types (including \ref lua_api_game "game",
\ref lua_api_item "items" and
\ref lua_api_entity "map entities"),
a fundamental property of maps is that even if they
are userdata, they can also be used like Lua tables.

This property is actually what allows you to define callbacks on your map.
But you can store any data in your map object,
including new functions specific to your particular map.
Here is an example that uses this feature:
\verbatim
-- Example of a map with 3 switches to activate in the correct order.
-- We assume that 3 switches exist with names "switch_1", "switch_2" and "switch_3".
local map = ...

function map:on_started()
  map.next_switch_index = 1
  -- Equivalent to: map["next_switch_index"] = 1
end

-- Called when the player walks on the switch named "switch_1".
function switch_1:on_activated()
  -- Check that switch_1 is the correct switch to activate.
  map:check_switch(self)
end

function switch_2:on_activated()
  map:check_switch(self)
end

function switch_3:on_activated()
  map:check_switch(self)
end

function map:check_switch(switch)
  if switch:get_name() == "switch_" .. map.next_switch_index then
    -- Okay so far.
    map.next_switch_index = map.next_switch_index + 1
    if map.next_switch_index > 3 then
      -- Finished!
      sol.audio.play_sound("secret")
      map:start_dialog("congratulations")
    end
  else
    -- Wrong switch: reset the puzzle.
    sol.audio.play_sound("wrong")
    switch_1:set_activated(false)
    switch_2:set_activated(false)
    switch_3:set_activated(false)
    map.next_switch_index = 1
  end
end
\endverbatim
In this example, you see that we add two values to the map object, like it
was a table:
\c next_switch_index (a number) and
\c check_switch (a function).

But the example has some issues.
The three \ref lua_api_switch "switches" are managed by duplicated code.
This is error-prone because and one day, we will probably want to make a similar
puzzle with 50 entities instead of just 3.
To make your map easier to maintain, the following and equivalent version is
much preferred:
\verbatim
local map = ...

-- Get the number of entities starting with "switch_".
map.nb_switches = map:get_entities_count("switch_")

function map:on_started()
  map.next_switch_index = 1
end

function switch_1:on_activated()
  map:check_switch(self)
end

for i = 2, map.nb_switches do
  -- Define the same on_activated() method as switch_1
  map_get_entity("switch_" .. i).on_activated = switch_1.on_activated
end

function map:check_switch(switch)
  if switch:get_name() == "switch_" .. map.next_switch_index then
    -- Okay so far.
    map.next_switch_index = map.next_switch_index + 1
    if map.next_switch_index > map.nb_switches then
      -- Finished!
      sol.audio.play_sound("secret")
      map:start_dialog("congratulations")
    end
  else
    -- Wrong switch: reset the puzzle.
    sol.audio.play_sound("wrong")
    for i = 1, map.nb_switches do
      map:get_entity("switch_" .. i):set_activated(false)
    end
    map.next_switch_index = 1
  end
end
\endverbatim

This improved version is more evolutive: it does not even hardcode the number
of \ref lua_api_switch "switches" in the puzzle.
Thus, if you add switch called \c "switch_4" from the editor,
the script will be directly take it into account in the puzzle.

\section lua_api_map_methods Methods of the type map

\subsection lua_api_map_get_id map:get_id()

Returns the id of this map.
- Return value (string): Id of the map.

\remark This id appears in the name of \ref
  lua_api_map_overview_files "map files".

\subsection lua_api_map_get_game map:get_game()

Returns the current game.
- Return value (\ref lua_api_game "game"): The game that is currently running
  the map.

\subsection lua_api_map_get_world map:get_world()

Returns the world name that was set on this map.

The world name is a property defined in the
\ref lua_api_map_overview_files "map data file".
Worlds allow to group maps together.
The world can be any arbitrary name. Maps that have the same world name
are considered to be part of the same environment.
For example, your map can be in a world named \c "outside_world",
\c "dungeon_1" or \c "some_scary_cave".

The world property is used to decide when to set the starting location of
the player (the place where he starts when loading his
\ref lua_api_game "savegame").
The starting location is automatically set by the engine
when the world changes (not when the map changes).

Some other features may also rely on the world property, like the state of
\ref lua_api_crystal_switch "crystal switches". Their state persists
between all maps of the current world and is reset when the world changes.
- Return value (string): Name of the world of the current map.

\subsection lua_api_get_floor map:get_floor()

Returns the floor of the current map if any.

The floor is an optional property defined in the
\ref lua_api_map_overview_files "map data file".

The engine does not do anything particular with this floor property.
But you can use it in scripts,
for example to show the current floor on the HUD
when it changes or to make a minimap \ref lua_api_menu "menu".
- Return value (number): The current floor. \c 0 is the first floor, \c 1
  is the second floor, \c -1 is the first basement floor, etc.
  \c nil means that this map is not part of a floor system.

\subsection lua_api_get_size map:get_size()

Returns the size of this map in pixels.
- Return value 1 (number): The width in pixels (always a multiple of 8).
- Return value 2 (number): The height in pixels (always a multiple of 8).

\subsection lua_api_get_location map:get_location()

Returns the x,y location of this map in its
\ref lua_api_map_get_world "world".

The engine uses this information to implement scrolling between two adjacent
maps.

For example, you can also use this property in scripts if you want to show
the position
of the hero on the minimap \ref lua_api_menu "menu" of your outside
\ref lua_api_map_get_world "world".
Indeed, your outside world is probably not a single map, but it is usually
composed of several adjacent maps.
- Return value 1 (number): X position of the top-left corner of this map
  relative to its world.
- Return value 2 (number): Y position of the top-left corner of this map
  relative to its world.

\subsection lua_api_get_tileset map:get_tileset()

Returns the name of the \ref lua_api_map_overview_tileset "tileset"
of the current map.
- Return value (string): Id of the current tileset.

\subsection lua_api_set_tileset map:set_tileset(tileset_id)

Changes the \ref lua_api_map_overview_tileset "tileset"
of the current map.

It is your responsability to make sure that
the new tileset is be compatible with the previous one:
every tile of the previous tileset must exist in the new one
and have the exact same properties, and only the images can differ.
Internally, this function actually keeps the data of the previous tileset
and only loads the image of the new tileset.
- \c tileset_id (string): Id of the new tileset to set.

\remark If the new tileset is not compatible with the previous one,
  tiles will be displayed with wrong graphics.




- \c sol.map.dialog_start(dialog_id):
Show a dialog box.

- \c sol.map.dialog_set_variable(dialog_id, value):
Specifies a value to display inside a dialog (for example the
player's name). In this dialog, the sequence \c $v will
be substituted by this value.

- \c sol.map.dialog_set_style(style):
Sets the style of the dialog box for subsequent dialogs (0: usual dialog box,
1: no dialog box, only display the text)

- \c sol.map.hud_set_pause_enabled(bool enabled):
Allows or disallows to pause the game (and thus to save the game).

- \c sol.map.hud_set_enabled(enabled):
Hides or restores the HUD (the player can still use his items
and pause the game).

- \c sol.map.light_get():
returns the current light level of the map

- \c sol.map.light_set(light_level):
sets the light level of the map (0: no light, positive values: full light)

- \c sol.map.camera_move(x, y, speed, function, delay_before, delay_after):
moves the camera to a target point (a usual speed value is 250),
waits a delay in milliseconds (default is 1000), calls a function,
waits another delay (default is 1000) and restores the camera;
the game is suspended during the whole sequence

- \c sol.map.tileset_get():
returns the id of the tileset of this map

- \c sol.map.tileset_set(tileset_id):
Changes the tileset used to draw the map.
The new tileset must be compatible with the previous one,
i.e. every tile of the previous tileset must exist in the new one
and have the same properties.
This function keeps the tiles of the previous tileset and loads the
image of the new tileset.

- \c sol.map.sprite_display(sprite, x, y):
Displays a sprite at the given position (relative to the the map top-left
corner). The origin point of the sprite will be displayed at this location.

*/

