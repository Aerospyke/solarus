/**
\page lua_api_map Map

\tableofcontents

Maps are areas where the \ref lua_api_game "game" takes place.
They may be rooms, houses, entire dungeon floors, parts of the outside
world or any place.
The active map contains many objects called
\ref lua_api_entity "map entities" (or just "entities" to be short).
%Map entities include everything that has a position on the map:
the \ref lua_api_hero "hero",
the \ref lua_api_tile "tiles",
the \ref lua_api_enemy "enemies",
the \ref lua_api_pickable "pickable treasures", etc.
See the \ref lua_api_entity "entity API" for more details.

\section lua_api_map_features Map features

\subsection lua_api_map_features_position Position of entities

A map has a rectangular size in pixels. The width and the height are always
multiples of 8 pixels, and most \ref lua_api_entity "map entities" usually
stay aligned on a grid of squares of 8*8 pixels (except when they are moving).

Thus, each \ref lua_api_entity "entity" has some coordinates <tt>X,Y</tt>
on the map. But its position is also defined by a third value: its layer.
The map has 3 distinct layers that are stacked: the low layer, the
intermediate layer and the high layer.
Each layer has its own set of entities.
Layers allow to implement maps with multi-level content, like a bridge
between two higher platforms. The \ref lua_api_hero "hero" 
(as well as \ref lua_api_enemy "enemies" and any other
\ref lua_api_entity "map entity") is then able to
walk either above or under the bridge, depending on his layer.
Entities like \ref lua_api_stairs "stairs" and
\ref lua_api_jumper "jumpers" can change the layer of the hero
automatically, and you can also do that from your Lua script.

\subsection lua_api_map_features_tileset Tileset

The graphic skin of a map is called a \ref tileset_syntax "tileset". The
tileset defines the small patterns used to draw \ref lua_api_tile "tiles"
and also some other \ref lua_api_entity "entities" that may depend on the
skin.
For example, you can have a forest tileset, a castle tileset, etc.
Each map has only one tileset, but tilesets have no special size limitation.

\subsection lua_api_map_features_files Map files

A map can contain many types of \ref lua_api_entity "entities".
%Map entities can be either declared in the
map data file or created dynamically.
Thus, a map named \c XXXX is managed by two distinct files:
- In the data file <tt>maps/XXXX.dat</tt> are declared all entities that
  initially compose your map (most importantly: the
  \ref lua_api_tile "tiles").
  You normally don't need to edit this file by hand:
  you can use the quest editor
  (but if you want to, \ref map_syntax "here is the syntax").
- In the script file <tt>maps/XXXX.lua</tt> (which is optional),
  you define the dynamic behavior
  of your map, using the features of the map Lua type described on this page
  (but the rest of the Solarus API will also be very useful).

When the player enters a map, the engine first creates the \ref lua_api_entity
"entities"
declared in the map data file
<tt>maps/XXXX.dat</tt>, and then it runs your script
<tt>maps/XXXX.lua</tt>.
The Lua map object is passed as parameter of your script
(any Lua script is implicitly a function and can have parameters).
Use the Lua notation \c "..." to get this parameter and store
it into a regular variable.

Here is a basic example of script for a map that does nothing special
except turning the lights off and showing an evil welcome dialog when the
hero enters it.
\verbatim
-- First, we put the parameter into a variable called "my_map".
-- (In Lua, the notation "..." refers to the parameter(s) of the script.)
local my_map = ...

-- Event called when the player enters the map, at initialization time.
function my_map:on_started()

  -- Put the room into the dark (before the first draw).
  self:set_light(0)
end

-- Event called when the player enters the map, after the opening transition.
function my_map:on_opening_transition_finished()

  -- Show an evil welcome dialog.
  self:start_dialog("welcome_to_darkness")
end
\endverbatim

In practice, many maps have short scripts like this or even no script at all.
Sometimes, everything that you define in the data file
(with the help of the editor) is enough.
You need a script when there is something dynamic to program on your map:
opening a \ref lua_api_door "door" when a
\ref lua_api_switch "pressure plate" is pressed,
making a \ref lua_api_chest "treasure chest" appear when some
\ref lua_api_enemy "enemies" are killed,
showing a dialog with an \ref lua_api_npc "NPC" that depends on
whether the player has accomplished a particular action before, etc. 

\subsection lua_api_map_features_lifetime Lifetime of maps

At any moment, during the \ref lua_api_game "game",
only one map is active:
the one drawn on the game screen.
That map is also the one where the \ref lua_api_hero "hero"
is currently located.
Only the active map has its entities living in it.
Other maps are not loaded. If the player leaves the map and comes back later,
your Lua map object will be a new one the second time.
Your entities will be reloaded as specified in the
\ref map_syntax "map data file" and your map script will be executed again.

If you want some data or behavior to persist when the player comes back,
like the position of an \ref lua_api_npc "NPC" or whether a puzzle was solved,
you can store the information into the \ref lua_api_game_set_value "savegame".
Alternatively, if you don't want these data to be saved, but you want to
remember it during the current \ref lua_api_game "game" session,
you can store the information as a field the
\ref lua_api_game "game" object. The game object persists until the player
stops playing and comes back to the title screen or restarts the game.

\remark Some entities save their state automatically if you want, like
whether a \ref lua_api_chest "treasure chest" is open, whether a
\ref lua_api_door "door" is open or whether an \ref lua_api_enemy "enemy"
is killed. Therefore, you have nothing to do for such entities: they keep
their state.

\subsection lua_api_map_features_table Accessing maps like tables

TODO map accessed like table (example)

\section lua_api_map_methods Methods of the type map

- \c sol.map.dialog_start(dialog_id):
Show a dialog box.

- \c sol.map.dialog_set_variable(dialog_id, value):
Specifies a value to display inside a dialog (for example the
player's name). In this dialog, the sequence \c $v will
be substituted by this value.

- \c sol.map.dialog_set_style(style):
Sets the style of the dialog box for subsequent dialogs (0: usual dialog box,
1: no dialog box, only display the text)

- \c sol.map.hud_set_pause_enabled(bool enabled):
Allows or disallows to pause the game (and thus to save the game).

- \c sol.map.hud_set_enabled(enabled):
Hides or restores the HUD (the player can still use his items
and pause the game).

- \c sol.map.light_get():
returns the current light level of the map

- \c sol.map.light_set(light_level):
sets the light level of the map (0: no light, positive values: full light)

- \c sol.map.camera_move(x, y, speed, function, delay_before, delay_after):
moves the camera to a target point (a usual speed value is 250),
waits a delay in milliseconds (default is 1000), calls a function,
waits another delay (default is 1000) and restores the camera;
the game is suspended during the whole sequence

- \c sol.map.tileset_get():
returns the id of the tileset of this map

- \c sol.map.tileset_set(tileset_id):
Changes the tileset used to draw the map.
The new tileset must be compatible with the previous one,
i.e. every tile of the previous tileset must exist in the new one
and have the same properties.
This function keeps the tiles of the previous tileset and loads the
image of the new tileset.

- \c sol.map.sprite_display(sprite, x, y):
Displays a sprite at the given position (relative to the the map top-left
corner). The origin point of the sprite will be displayed at this location.

*/

